<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Fish Shell 登录时智能切换目录：`status` 命令的应用</title>
      <link href="/2025/05/16/Fish-Shell-%E7%99%BB%E5%BD%95%E6%97%B6%E6%99%BA%E8%83%BD%E5%88%87%E6%8D%A2%E7%9B%AE%E5%BD%95%EF%BC%9A-status-%E5%91%BD%E4%BB%A4%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2025/05/16/Fish-Shell-%E7%99%BB%E5%BD%95%E6%97%B6%E6%99%BA%E8%83%BD%E5%88%87%E6%8D%A2%E7%9B%AE%E5%BD%95%EF%BC%9A-status-%E5%91%BD%E4%BB%A4%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Fish-Shell-登录时智能切换目录：status-命令的应用"><a href="#Fish-Shell-登录时智能切换目录：status-命令的应用" class="headerlink" title="Fish Shell 登录时智能切换目录：status 命令的应用"></a>Fish Shell 登录时智能切换目录：<code>status</code> 命令的应用</h1><p>笔者最近在日常使用 Fish Shell 的过程中，遇到了一个小需求，希望能让我在通过 SSH 首次登录服务器时自动切换到一个常用的工作目录，但同时又不影响后续在该会话中（比如通过 VS Code Remote 或者直接新开终端标签页）创建新终端时的默认路径行为。经过一番探索，发现 Fish Shell 强大的 <code>status</code> 命令能够完美解决这个问题。</p><h2 id="问题的提出：便利性与常规操作的冲突"><a href="#问题的提出：便利性与常规操作的冲突" class="headerlink" title="问题的提出：便利性与常规操作的冲突"></a>问题的提出：便利性与常规操作的冲突</h2><p>很多时候，我们登录服务器后，第一个操作往往是 <code>cd</code> 到某个固定的项目目录。如果能让 Shell 自动完成这个操作，无疑能提升些许效率。</p><p>一个直接的想法可能是在 Fish Shell 的配置文件 <code>~/.config/fish/config.fish</code> 中直接加入一行 <code>cd /path/to/my/project</code>。然而，这样做有一个明显的弊端：<code>config.fish</code> 文件会在<strong>每一个</strong> Fish Shell 实例启动时被加载执行。这意味着：</p><ol><li><strong>首次 SSH 登录</strong>：确实会切换到指定目录，符合预期。</li><li><strong>打开新的终端标签页</strong>：新标签页也会自动 <code>cd</code> 到那个指定目录，而不是用户期望的默认目录（通常是 <code>$HOME</code> 或上一个终端的路径）。</li><li><strong>VS Code 打开集成终端</strong>：当使用 VS Code 连接到远程服务器并在特定项目文件夹下工作时，VS Code 打开的集成终端也会被强制 <code>cd</code> 到 <code>config.fish</code> 中指定的目录，而不是 VS Code 当前工作区的目录。这就破坏了 VS Code 良好的集成体验。</li></ol><p>显然，我们需要一种更智能的方式来区分“首次登录”和“后续打开的终端”。</p><h2 id="fish-status-命令：洞察-Shell-的状态"><a href="#fish-status-命令：洞察-Shell-的状态" class="headerlink" title="fish status 命令：洞察 Shell 的状态"></a><code>fish status</code> 命令：洞察 Shell 的状态</h2><p>Fish Shell 提供了一个非常方便的内建命令 <code>status</code>，它可以用来查询当前 Shell 的各种运行时信息。其中，对我们解决这个问题至关重要的是 <code>status --is-login</code> 这个子命令。</p><ul><li><code>status --is-login</code>：这个命令会判断当前的 Shell 会话是否为一个“登录 Shell”（Login Shell）。通常情况下，我们通过 SSH 客户端连接到服务器时，初始建立的 Shell 会话就是一个登录 Shell。而之后在该会话中新开的终端（如新的标签页、VS Code 的集成终端等）则通常是“交互式非登录 Shell”（Interactive Non-Login Shell）。</li></ul><p>利用这个特性，我们就可以在 <code>config.fish</code> 中加入条件判断。</p><h2 id="解决方案：修改-config-fish"><a href="#解决方案：修改-config-fish" class="headerlink" title="解决方案：修改 config.fish"></a>解决方案：修改 <code>config.fish</code></h2><p>我们可以在 <code>~/.config/fish/config.fish</code> 文件中添加以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># ~/.config/fish/config.fish</span><br><span class="line"></span><br><span class="line"># 判断当前是否为登录 Shell</span><br><span class="line">if status --is-login</span><br><span class="line">    # 如果是登录 Shell，则切换到指定的目录</span><br><span class="line">    # 请将下面的路径替换为您希望登录时进入的实际文件夹路径</span><br><span class="line">    cd /path/to/your/desired/login_folder</span><br><span class="line">    </span><br><span class="line">    # （可选）可以加一条输出来确认操作，方便调试</span><br><span class="line">    # echo &quot;Login shell detected. Changed directory to (pwd)&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><strong>代码解释：</strong></p><ol><li><code>if status --is-login</code>: 这行代码检查当前 Shell 是否为登录 Shell。如果是，<code>status --is-login</code> 命令会返回状态码 <code>0</code> (表示真)，<code>if</code> 条件成立。</li><li><code>cd /path/to/your/desired/login_folder</code>: 只有在 <code>if</code> 条件成立时（即为登录 Shell 时），这行 <code>cd</code> 命令才会被执行，将目录切换到您指定的工作路径。</li><li><code>end</code>: 结束 <code>if</code>语句块。</li></ol><p><strong>效果：</strong></p><ul><li><strong>首次 SSH 登录服务器</strong>：<ul><li>Fish Shell 启动，加载 <code>config.fish</code>。</li><li><code>status --is-login</code> 判断为真。</li><li><code>cd /path/to/your/desired/login_folder</code> 执行，自动进入指定目录。</li></ul></li><li><strong>在已登录的会话中，通过 VS Code 打开集成终端，或手动打开新的终端标签页</strong>：<ul><li>新的 Fish Shell 实例启动，加载 <code>config.fish</code>。</li><li>这些 Shell 通常是交互式的，但<strong>不是</strong>登录 Shell，因此 <code>status --is-login</code> 判断为假。</li><li><code>if</code> 语句块内的 <code>cd</code> 命令<strong>不会</strong>被执行。</li><li>VS Code 的终端会正常打开在当前项目的工作区路径，新的终端标签页也会在默认路径（如家目录或上一个活动目录）打开。</li></ul></li></ul><h2 id="status-命令子命令概览"><a href="#status-命令子命令概览" class="headerlink" title="status 命令子命令概览"></a><code>status</code> 命令子命令概览</h2><p><code>status</code> 命令不仅仅用于判断登录状态，它还提供了丰富的子命令来查询和控制 Shell 的各种运行时信息。以下是一些常用的 <code>status</code> 子命令：</p><h3 id="Shell-会话类型与模式"><a href="#Shell-会话类型与模式" class="headerlink" title="Shell 会话类型与模式"></a>Shell 会话类型与模式</h3><ul><li><code>status is-interactive</code> (或 <code>-i</code>, <code>--is-interactive</code>):<br>  判断当前 Shell 是否为交互式模式（即连接到键盘）。</li><li><code>status is-login</code> (或 <code>-l</code>, <code>--is-login</code>):<br>  判断当前 Shell 是否为登录 Shell。</li><li><code>status is-command-substitution</code> (或 <code>-c</code>, <code>--is-command-substitution</code>):<br>  判断当前 Shell 是否正在执行命令替换。</li><li><code>status is-block</code> (或 <code>-b</code>, <code>--is-block</code>):<br>  判断当前 Shell 是否正在执行一个代码块。</li><li><code>status is-breakpoint</code>:<br>  判断当前 Shell 是否处于断点命令的提示符上下文中。</li><li><code>status is-interactive-read</code>:<br>  判断 Fish 是否正在运行一个连接到键盘的交互式 <code>read</code> 内建命令。</li></ul><h3 id="作业控制-Job-Control"><a href="#作业控制-Job-Control" class="headerlink" title="作业控制 (Job Control)"></a>作业控制 (Job Control)</h3><ul><li><code>status is-full-job-control</code> (或 <code>--is-full-job-control</code>):<br>  判断是否启用了完整的作业控制。</li><li><code>status is-interactive-job-control</code> (或 <code>--is-interactive-job-control</code>):<br>  判断是否启用了交互式作业控制。</li><li><code>status is-no-job-control</code> (或 <code>--is-no-job-control</code>):<br>  判断是否未启用作业控制。</li><li><code>status job-control &lt;TYPE&gt;</code> (或 <code>-j &lt;TYPE&gt;</code>, <code>--job-control=&lt;TYPE&gt;</code>):<br>  设置作业控制的类型，<code>&lt;TYPE&gt;</code> 可以是 <code>none</code>, <code>full</code>, 或 <code>interactive</code>。</li></ul><h3 id="当前执行上下文信息"><a href="#当前执行上下文信息" class="headerlink" title="当前执行上下文信息"></a>当前执行上下文信息</h3><ul><li><code>status current-command</code>:<br>  打印当前正在运行的函数或命令的名称。</li><li><code>status current-commandline</code>:<br>  打印当前正在运行的完整命令行。</li><li><code>status filename</code> (或 <code>current-filename</code>, <code>-f</code>, <code>--current-filename</code>):<br>  打印当前正在运行的脚本的文件名。</li><li><code>status basename</code>:<br>  仅打印正在运行脚本的文件名部分，不包括路径。</li><li><code>status dirname</code>:<br>  仅打印正在运行脚本的路径部分。</li><li><code>status function</code> (或 <code>current-function</code>, <code>-u</code>, <code>--current-function</code>):<br>  打印当前被调用函数的名称。</li><li><code>status line-number</code> (或 <code>current-line-number</code>, <code>-n</code>, <code>--current-line-number</code>):<br>  打印当前正在运行脚本的行号。</li></ul><h3 id="调用栈与-Fish-实例信息"><a href="#调用栈与-Fish-实例信息" class="headerlink" title="调用栈与 Fish 实例信息"></a>调用栈与 Fish 实例信息</h3><ul><li><code>status stack-trace</code> (或 <code>print-stack-trace</code>, <code>-t</code>, <code>--print-stack-trace</code>):<br>  打印调用栈上所有函数调用的堆栈跟踪。</li><li><code>status fish-path</code>:<br>  打印当前执行的 Fish 实例的绝对路径。</li></ul><h3 id="特性标志-Feature-Flags"><a href="#特性标志-Feature-Flags" class="headerlink" title="特性标志 (Feature Flags)"></a>特性标志 (Feature Flags)</h3><ul><li><code>status features</code>:<br>  列出所有可用的特性标志及其当前状态 (on/off)。</li><li><code>status test-feature &lt;FEATURE_NAME&gt;</code>:<br>  测试特定的特性标志是否启用。</li></ul><h3 id="无参数调用"><a href="#无参数调用" class="headerlink" title="无参数调用"></a>无参数调用</h3><ul><li><code>status</code> (不带任何子命令):<br>  显示一个关于 Shell 当前登录状态和作业控制状态的摘要。</li></ul><p>这些子命令为 Fish Shell 脚本编写和环境定制提供了强大的工具。通过 <code>man status</code> 或 <code>status --help</code> 可以获取更详细和最新的信息。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过在 <code>~/.config/fish/config.fish</code> 中巧妙运用 <code>status --is-login</code> 进行条件判断，我们成功实现了仅在首次登录服务器时自动切换到指定工作目录，而完全不干扰后续在该会话中打开新终端（尤其是 VS Code 集成终端）的正常行为。同时，了解 <code>status</code> 命令的其他子命令也能帮助我们更好地掌控和定制 Fish Shell 环境。</p><p>这再次体现了 Fish Shell 设计的人性化和功能的灵活性，一个小小的 <code>status</code> 命令就能优雅地解决这类常见的配置需求，提升我们的工作效率和使用体验。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Fish Shell </tag>
            
            <tag> CLI </tag>
            
            <tag> Productivity </tag>
            
            <tag> Shell Scripting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lattice based commitment scheme</title>
      <link href="/2025/05/13/Lattice-based-commitment-scheme/"/>
      <url>/2025/05/13/Lattice-based-commitment-scheme/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇博客利用prompt工程撰写</p></blockquote><h1 id="格密码承诺方案：-Ajtai-BDLOP-和-ADBLOP"><a href="#格密码承诺方案：-Ajtai-BDLOP-和-ADBLOP" class="headerlink" title="格密码承诺方案： Ajtai , BDLOP 和 ADBLOP"></a>格密码承诺方案： Ajtai , BDLOP 和 ADBLOP</h1><p>在密码学领域，承诺方案 (Commitment Scheme) 扮演着至关重要的角色。它允许一方（承诺者）对某个值或声明进行承诺，同时保持该值的秘密性（隐藏性），并在稍后阶段向另一方（验证者）揭示该值（绑定性）。近年来，随着量子计算的兴起对传统公钥密码体系构成威胁，基于格的密码学 (Lattice-based Cryptography) 因其抗量子特性而受到广泛关注。本文将探讨几种基于格的承诺方案，特别是 Lantern 提出的结合了 Ajtai 和 BDLOP 方案优势的新型 ABDLOP 方案。</p><h2 id="承诺方案的核心属性"><a href="#承诺方案的核心属性" class="headerlink" title="承诺方案的核心属性"></a>承诺方案的核心属性</h2><p>一个安全的承诺方案通常需要满足两个基本属性：</p><ol><li><strong>隐藏性 (Hiding):</strong> 承诺本身不会泄露关于承诺值的任何信息。</li><li><strong>绑定性 (Binding):</strong> 承诺者一旦做出承诺，就不能在揭示阶段改变承诺的值。</li></ol><h2 id="Ajtai-承诺方案"><a href="#Ajtai-承诺方案" class="headerlink" title="Ajtai 承诺方案"></a>Ajtai 承诺方案</h2><p>Ajtai 承诺方案是一种经典的基于格的方案。其核心思想是利用格中的短向量问题 (Shortest Vector Problem, SVP) 或最近向量问题 (Closest Vector Problem, CVP) 的困难性。</p><p>在该方案中，承诺者想要承诺一个消息 $\mathbf{s}_1$。为此，他会选择一个随机向量 $\mathbf{s}_2$，其中 $\mathbf{s}_1$ 和 $\mathbf{s}_2$ 的范数（长度）都要求很小。承诺的计算方式如下：</p><script type="math/tex; mode=display">\mathbf{A}_1 \mathbf{s}_1 + \mathbf{A}_2 \mathbf{s}_2 = \mathbf{t}</script><p>这里：</p><ul><li>$\mathbf{A}_1$ 和 $\mathbf{A}_2$ 是公开的矩阵。</li><li>$\mathbf{s}_1$ 是要承诺的消息。</li><li>$\mathbf{s}_2$ 是承诺者选择的随机值（也称为盲化因子）。</li><li>$\mathbf{t}$ 是生成的承诺。</li></ul><p>为了揭示承诺，承诺者需要公开 $\mathbf{s}_1$ 和 $\mathbf{s}_2$。验证者可以通过检查等式是否成立以及 $\mathbf{s}_1$ 和 $\mathbf{s}_2$ 是否确实是“小”向量来验证承诺。由于找到满足该等式的其他短向量对 $(\mathbf{s}_1’, \mathbf{s}_2’)$ 非常困难，因此该方案具有绑定性。同时，由于存在许多可能的 $\mathbf{s}_2$ 可以生成相同的 $\mathbf{t}$（对于不同的 $\mathbf{s}_1$），因此方案也具有隐藏性。</p><h2 id="BDLOP-承诺方案"><a href="#BDLOP-承诺方案" class="headerlink" title="BDLOP 承诺方案"></a>BDLOP 承诺方案</h2><p>BDLOP 承诺方案 ([BDL+18]) 是另一种重要的基于格的承诺方案。它允许承诺者对消息 $\mathbf{m}$ 进行承诺，并使用随机性 $\mathbf{s}$。其承诺形式如下：</p><script type="math/tex; mode=display">\left[\begin{array}{l}\mathbf{A} \\\mathbf{B}\end{array}\right] \mathbf{s} + \left[\begin{array}{c}\mathbf{0} \\\mathbf{m}\end{array}\right] = \left[\begin{array}{l}\mathbf{t}_A \\\mathbf{t}_B\end{array}\right]</script><p>这里：</p><ul><li>$\mathbf{A}$ 和 $\mathbf{B}$ 是公开的矩阵。</li><li>$\mathbf{s}$ 是承诺者选择的随机向量。</li><li>$\mathbf{m}$ 是要承诺的消息。</li><li>$\mathbf{0}$ 是一个零向量。</li><li>$\left[\begin{array}{l} \mathbf{t}_A \ \mathbf{t}_B \end{array}\right]$ 是生成的承诺。</li></ul><p>BDLOP 方案的一个有趣特性是它可以扩展到承诺多个消息。例如，如果除了 $\mathbf{m}$ 之外，还需要承诺另一个消息 $\mathbf{m}’$，可以使用公开的随机性 $\mathbf{B}’$ 来计算新的承诺部分：$\mathbf{B}’ \mathbf{s} + \mathbf{m}’ = \mathbf{t}_{B’}’$。那么，对 $(\mathbf{m}, \mathbf{m}’)$ 的组合承诺就变成了：</p><script type="math/tex; mode=display">\left[\begin{array}{c}\mathbf{A} \\\mathbf{B} \\\mathbf{B}'\end{array}\right] \mathbf{s} + \left[\begin{array}{c}\mathbf{0} \\\mathbf{m} \\\mathbf{m}'\end{array}\right] = \left[\begin{array}{c}\mathbf{t}_A \\\mathbf{t}_B \\\mathbf{t}_{B'}'\end{array}\right]</script><p>这种结构在需要对复杂数据结构进行承诺时非常有用。</p><h2 id="Lantern-的-ABDLOP-承诺方案：融合与提升"><a href="#Lantern-的-ABDLOP-承诺方案：融合与提升" class="headerlink" title="Lantern 的 ABDLOP 承诺方案：融合与提升"></a>Lantern 的 ABDLOP 承诺方案：融合与提升</h2><p>为了追求更高的效率和灵活性，Lantern 提出了一种名为 ABDLOP 的新型承诺方案。顾名思义，ABDLOP 旨在结合 Ajtai 和 BDLOP 方案的优点。</p><p>ABDLOP 方案的承诺形式如下：</p><script type="math/tex; mode=display">\left[\begin{array}{c}\mathbf{A}_1 \\\mathbf{0}\end{array}\right] \mathbf{s}_1 + \left[\begin{array}{c}\mathbf{A}_2 \\\mathbf{B}\end{array}\right] \mathbf{s}_2 + \left[\begin{array}{c}\mathbf{0} \\\mathbf{m}\end{array}\right] = \left[\begin{array}{c}\mathbf{t}_A \\\mathbf{t}_B\end{array}\right]</script><p>这里：</p><ul><li>$\mathbf{A}_1, \mathbf{A}_2, \mathbf{B}$ 是公开的矩阵。</li><li>$\mathbf{s}_1$ 可以被看作是 Ajtai 方案中的消息部分，具有范数较小的特性。</li><li>$\mathbf{s}_2$ 可以被看作是 Ajtai 方案中的随机性部分，同时也扮演着 BDLOP 方案中随机性的角色，同样具有范数较小的特性。</li><li>$\mathbf{m}$ 是要承诺的附加消息，类似于 BDLOP 方案中的消息。</li><li>$\mathbf{0}$ 是零向量。</li><li>$\left[\begin{array}{c} \mathbf{t}_A \ \mathbf{t}_B \end{array}\right]$ 是生成的承诺。</li></ul><p>在揭示阶段，承诺者需要提供 $\mathbf{s}_1$ 和 $\mathbf{s}_2$ 来打开承诺。</p><p>通过这种结构，ABDLOP 方案试图同时利用 Ajtai 方案中对短向量 $\mathbf{s}_1$ 的承诺能力，以及 BDLOP 方案中对附加消息 $\mathbf{m}$ 进行承诺的灵活性。这种融合可能在特定的应用场景下带来效率或功能上的优势。例如，$\mathbf{s}_1$ 可能代表一些核心的、需要强绑定性和隐藏性的秘密值，而 $\mathbf{m}$ 则可能是一些辅助数据。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>基于格的承诺方案是构建抗量子密码系统的重要基石。Ajtai 和 BDLOP 方案各自提供了独特的特性和优势。Lantern 提出的 ABDLOP 方案通过巧妙地结合这两种方案的元素，为设计更高效、更灵活的密码协议开辟了新的可能性。随着对基于格密码学的深入研究，我们可以期待未来出现更多创新的承诺方案，为数字安全领域提供更强大的保障。</p><hr><p><strong>参考文献：</strong></p><ul><li>[Ajt96] Ajtai, M. (1996). Generating hard instances of lattice problems (extended abstract). In Proceedings of the twenty-eighth annual ACM symposium on Theory of computing (pp. 99-108).</li><li>[BDL+18] Baum, C., Damgård, I., Lyubashevsky, V., Oechsner, S., &amp; Peikert, C. (2018). Lattice-Based SNARGs and Their Application to Privacy-Preserving Computation. In Advances in Cryptology – ASIACRYPT 2018 (pp. 3-33). Springer. </li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Zero Knowledge Proof, AIGC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Algebraic Closure</title>
      <link href="/2025/04/02/Algebraic-Closure/"/>
      <url>/2025/04/02/Algebraic-Closure/</url>
      
        <content type="html"><![CDATA[<p>Recently, I’ve read some papers about the Elliptic Curve and found a general primitive - <strong>abelian variety</strong>. And when I was reading the paper, I found that the author mentioned the algebraic closure of a field, which I had not learned before. I want to write a blog to introduce this concept.</p><h2 id="Algebraically-Closed-Fields"><a href="#Algebraically-Closed-Fields" class="headerlink" title="Algebraically Closed Fields"></a>Algebraically Closed Fields</h2><p><strong>Proposition 1.</strong> Let $E$ be a field. We say that $E$ is algebraically closed if all non-constant polynomials in $E[x]$ have a root.</p><p><strong>Proposition 2.</strong> A field $F$ is said to be algebraically closed if every algebraic extension $E / F$ is trivial, i.e., $E=F$.</p><p><strong>Theorem 1.</strong> Let $F$ be a field. The following are equivalent<br>(1) $F$ is algebraically closed,<br>(2) every irreducible polynomial over $F$ is linear,<br>(3) every nonconstant polynomial over $F$ has a root,<br>(4) every nonconstant polynomial over $F$ is a product of linear factors.</p><p><strong>Proof.</strong> Proof. If $F$ is algebraically closed, then every irreducible polynomial is linear. Namely, if there exists an irreducible polynomial of degree $&gt;1$, then this generates a nontrivial finite (hence algebraic) field extension, see Example 9.7.6. Thus (1) implies (2). If every irreducible polynomial is linear, then every irreducible polynomial has a root, whence every nonconstant polynomial has a root. Thus (2) implies (3).</p><p>Assume every nonconstant polynomial has a root. Let $P \in F[x]$ be nonconstant. If $P(\alpha)=0$ with $\alpha \in F$, then we see that $P=(x-\alpha) Q$ for some $Q \in F[x]$ (by division with remainder). Thus we can argue by induction on the degree that any nonconstant polynomial can be written as a product $c \prod\left(x-\alpha_i\right)$.</p><p>Finally, suppose that every nonconstant polynomial over $F$ is a product of linear factors. Let $E / F$ be an algebraic extension. Then all the simple subextensions $F(\alpha) / F$ of $E$ are necessarily trivial (because the only irreducible polynomials are linear by assumption). Thus $E=F$. We see that (4) implies (1) and we are done.</p><p>Now we want to define a “universal” algebraic extension of a field. Actually, we should be careful: the algebraic closure is not a universal object. That is, the algebraic closure is not unique up to unique isomorphism: it is only unique up to isomorphism. But still, it will be very handy, if not functorial.</p><h2 id="Algebraically-Closure"><a href="#Algebraically-Closure" class="headerlink" title="Algebraically Closure"></a>Algebraically Closure</h2><p><strong>Definition 1.</strong> Let $F$ be a field. An algebraic closure of $F$ is a field $\bar{F}$ containing $F$ such that:<br>(1) $\bar{F}$ is algebraic over $F$.<br>(2) $\bar{F}$ is algebraically closed.</p><p>If $F$ is algebraically closed, then $F$ is its own algebraic closure. We now prove the basic existence result.</p><p><strong>Theorem 2.</strong> Every field has an algebraic closure.</p><p><strong>Proof.</strong> Let $F$ be a field. Let $\mathcal{X}$ be the set of all algebraic extensions of $F$.</p><p>Clearly, $F \in \mathcal{X} \neq \emptyset$.<br>Let $C$ be a chain in $\mathcal{X}$. Let</p><script type="math/tex; mode=display">E=\bigcup_{F^{\prime} \in C} F^{\prime} .</script><p>As $E$ is a union of ascending fields, it is clear that $E$ is itself a field.</p><p>We claim $E$ is an algebraic extension of $F$. Clearly, $F \subseteq E$ since every field in $C \neq \emptyset$ contains $F$. Let $\alpha \in E$. Then there exists some field $F^{\prime} \in C$ such that $\alpha \in F^{\prime}$. As $F^{\prime} / F$ is algebraic, we see that $\alpha$ is algebraic over $F$. Thus, $E / F$ is algebraic, that is, $E \in \mathcal{X}$.</p><p>As $F^{\prime} \subseteq E$ for all $F^{\prime} \in C$, every chain in $\mathcal{X}$ has an upper bound.</p><p>By Zorn’s Lemma, $\mathcal{X}$ has a maximal element, $\bar{F}$ Thus, $F^{\prime}$ is an algebraic closure of $F$, being a maximal algebraic extension.</p><p><strong>Zorn’s Lemma.</strong> Let $P$ be a partially ordered set. If every chain in $P$ has an upper bound, then $P$ has a maximal element.</p><p><strong>Lemma 1.</strong> Let $F$ be a field. Then $E$ is an algebraic closure of $F$ if and only if $E$ is a maximal algebraic extension of $F$.</p><p><strong>Lemma 2.</strong> Let $E / F$ be an algebraic extension of fields. Then the cardinality $|E|$ of $E$ is at most $\max \left(\aleph_0,|F|\right)$.</p><p><strong>Proof.</strong> Let $S$ be the set of nonconstant polynomials with coefficients in $F$. For every $P \in S$ the set of roots $r(P, E)=\{\alpha \in E \mid P(\alpha)=0\}$ is finite (details omitted). Moreover, the fact that $E$ is algebraic over $F$ implies that $E=\bigcup_{P \in S} r(P, E)$. It is clear that $S$ has cardinality bounded by $\max \left(\aleph_0,|F|\right)$ because it is a countable union of finite products of copies of $F$. Thus so does $E$.</p><p>When I saw lemma2, I was confused. As everyone knows, the cardinality of the extension of fields must be larger than the base field. I finally realized that I hadn’t noticed “at most” and “max.”</p><p>Then I thought about transcendental extensions and algebraic extensions.<br><img src="/imgs/algebraic_closure/algebraic.png" alt="alt text"></p><p><img src="/imgs/algebraic_closure/trans.png" alt="alt text"></p><p><img src="/imgs/algebraic_closure/diff.png" alt="alt text"></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] <a href="https://en.wikipedia.org/wiki/Algebraic_closure">https://en.wikipedia.org/wiki/Algebraic_closure</a></p><p>[2] <a href="https://en.wikipedia.org/wiki/Field_extension">https://en.wikipedia.org/wiki/Field_extension</a></p><p>[3] <a href="https://www.youtube.com/watch?v=y9358yg9SmQ">https://www.youtube.com/watch?v=y9358yg9SmQ</a></p><p>[4] <a href="https://www.youtube.com/watch?v=lN_c7KlKPlA">https://www.youtube.com/watch?v=lN_c7KlKPlA</a></p><p>[5] <a href="https://stacks.math.columbia.edu/tag/09GK">https://stacks.math.columbia.edu/tag/09GK</a></p><p>[6] <a href="https://stacks.math.columbia.edu/tag/09GP">https://stacks.math.columbia.edu/tag/09GP</a></p><p>[7] <a href="https://claude.ai/">https://claude.ai/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>What Can and Cannot Be Done - Bound in Code</title>
      <link href="/2025/03/25/What-Can-and-Cannot-Be-Done-Bound-in-Code/"/>
      <url>/2025/03/25/What-Can-and-Cannot-Be-Done-Bound-in-Code/</url>
      
        <content type="html"><![CDATA[<p>After a long “travel” in coding theory, I finally feel I have understand the <strong>Bound</strong>. So I come back to write down this blog in case I forget again in the future<br>In this blog, we will introduce some bounds used in coding theory.</p><h2 id="Hamming-Bound"><a href="#Hamming-Bound" class="headerlink" title="Hamming Bound"></a><strong>Hamming Bound</strong></h2><p><strong>Fact 1</strong> Let $C$ be a code with minimum distance $d$. For any $c, c^{\prime} \in C, c \neq c^{\prime}$, we have that $B\left(c,\left\lfloor\frac{d-1}{2}\right\rfloor\right)$ is disjoint from $B\left(c^{\prime},\left\lfloor\frac{d-1}{2}\right\rfloor\right)$.</p><p><strong>For Binary Code:</strong></p><p>Set $r=\left\lfloor\frac{d-1}{2}\right\rfloor$ ．It follows from Fact 1 that</p><script type="math/tex; mode=display">\left|\bigcup_{c \in C} B(c, r)\right|=\sum_{c \in C}|B(c, r)|=|C| \cdot|B(r)|</script><p>Also</p><script type="math/tex; mode=display">\bigcup_{c \in C} B(c, r) \subseteq\{0,1\}^n</script><p>and so we have</p><script type="math/tex; mode=display">\left|\bigcup_{c \in C} B(c, r)\right| \leq 2^n</script><p>which gives us</p><script type="math/tex; mode=display">|C| \leq \frac{2^n}{|B(r)|}</script><p>Thus，</p><script type="math/tex; mode=display">|C| \leq \frac{2^n}{\sum_{i=0}^{\lfloor(d-1) / 2\rfloor}\binom{n}{i}}</script><p><strong>Similarly, For q-ary case:</strong> </p><script type="math/tex; mode=display">|C| \leq \frac{q^n}{\sum_{i=0}^{\lfloor(d-1) / 2\rfloor}\binom{n}{i}(q-1)^i}</script><p><strong>As we all know, the correctable codeword must contain no more than $\lfloor(d-1) / 2\rfloor$ errors. So if we want every codeword to be correctable, the ball must be disjoint</strong></p><script type="math/tex; mode=display">\forall \mathcal{C}, |\mathcal{C}| \leq \frac{q^n}{\sum_{i=0}^{\lfloor(d-1) / 2\rfloor}\binom{n}{i}(q-1)^i}</script><script type="math/tex; mode=display">\forall C \quad R \leq 1-H\left(\frac{\delta}{\Omega}\right)+o(1)</script><h2 id="Gilbert–Varshamov-bound"><a href="#Gilbert–Varshamov-bound" class="headerlink" title="Gilbert–Varshamov bound"></a><strong>Gilbert–Varshamov bound</strong></h2><p>In my understanding, we can regard GV bound as a <strong>greedy</strong> approach to construct code.</p><p><strong>For Binary Code:</strong></p><ul><li>Set $S=\{0,1\}^n$ and let $C=\emptyset$.</li><li>As long as $S \neq \emptyset$, pick a point $v \in S$ and add $v$ to $C$. Remove $B(v, d-1)$ from $S$, i.e. $S=S \backslash B(v, d-1)$.</li></ul><p>Notice that we are removing at most $\sum_{i=0}^{d-1}\binom{n}{i}$ points from $S$ in every iteration. Since we add one element to $C$ in each iteration, we have that</p><script type="math/tex; mode=display">|C| \geq \frac{2^n}{\sum_{i=0}^{d-1}\binom{n}{i}}</script><p><strong>Similarly, For q-ary case:</strong> </p><script type="math/tex; mode=display">|C| \geq \frac{q^n}{\sum_{i=0}^{d-1}\binom{n}{i}(q-1)^i}</script><p>This is a constructive proof, so</p><script type="math/tex; mode=display">\exists \mathcal{C}, |\mathcal{C}|\geq \frac{q^n}{\sum_{i=0}^{d-1}\binom{n}{i}(q-1)^i}</script><script type="math/tex; mode=display">\begin{aligned}&\text { When } \delta<\frac{1}{2} \text { : }\\&\exists C \quad R \geq 1-H(\delta)-o(1)\end{aligned}</script><h2 id="Plotkin-Bound"><a href="#Plotkin-Bound" class="headerlink" title="Plotkin Bound"></a><strong>Plotkin Bound</strong></h2><p>Plotkin Bound answer the question that</p><script type="math/tex; mode=display">\text { What is the best trade-off for } R, \delta \text { ? }</script><p>The proof proceeds by shortening the codewords. We group the codewords so that they agree on the first $n-n^{\prime}$ places, where $n^{\prime}=\left\lfloor\frac{q d}{q-1}\right\rfloor-1$. In particular, for any $x \in[q]^{n-n^{\prime}}$, define</p><script type="math/tex; mode=display">C_x=\left\{\left(c_{n-n^{\prime}+1}, \ldots c_n\right) \mid\left(c_1 \ldots c_N\right) \in C,\left(c_1 \ldots c_{n-n^{\prime}}\right)=x\right\}</script><p>Define $d=\delta n$. For all $x, C_x$ has distance $d$ as $C$ has distance $d .{ }^1$ Additionally, it has block length $n^{\prime}&lt;\left(\frac{q}{q-1}\right) d$ and thus, $d&gt;\left(1-\frac{1}{q}\right) n^{\prime}$. By sphere-packing bound,</p><script type="math/tex; mode=display">|C_x| \leq \frac{q^{n'}}{\sum_{i=0}^{t} \binom{n'}{i}(q-1)^i}</script><p>this implies that</p><script type="math/tex; mode=display">\left|C_x\right| \leq \frac{q d}{q d-(q-1) n^{\prime}} \leq q d</script><p>where the second inequality follows from the facts that $d&gt;(1-1 / q) n^{\prime}$ and that $q d-(q-1) n^{\prime}$ is an integer.</p><p>Note that by the definition of $C_x$ :</p><script type="math/tex; mode=display">|C|=\sum_{x \in[q]^{n-n^{\prime}}}\left|C_x\right|</script><p>which by (1) implies that</p><script type="math/tex; mode=display">|C| \leq \sum_{x \in[q]^{n-n^{\prime}}} q d=q^{n-n^{\prime}} \cdot q d \leq q^{n-\frac{q}{q-1} d+o(n)}</script><p>In other words, $R \leq 1-\left(\frac{q}{q-1}\right) \delta+o(1)$ as desired.</p><p><strong>For binary case, we have $R+2\delta \leq 1$</strong></p><h2 id="Singleton-Bound"><a href="#Singleton-Bound" class="headerlink" title="Singleton Bound"></a><strong>Singleton Bound</strong></h2><script type="math/tex; mode=display">\text { Let } \mathcal{C} \text { be a code of any alphabet size. Then } \mathcal{C} \text { has rate } R \leq 1-\delta+o(1) \text {. }</script><p> Delete last $\delta n-1$ coordinates of all codewords in $\mathcal{C}$. All remaining codewords are distinct (as otherwise two identified codewords would have had distance $\delta n-1&lt;\delta n$ ). Further all remaining shortened codewords lie in $\Sigma^{(1-\delta) n+1}$. Therefore $|\mathcal{C}| \leq|\Sigma|^{(1-\delta) n+1}$. So we directly have that the rate is $R \leq 1-\delta+\frac{1}{n}$.</p><p>It looks like Singleton Bound above the Plotkin bound. This is possible beacause $R+2\delta \leq 1$ only for binary case</p><p><img src="/imgs/bound.png" alt="alt text"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Coding Theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Additive Fast Fourier Transformation</title>
      <link href="/2025/03/15/Additive-Fast-Fourier-Transformation/"/>
      <url>/2025/03/15/Additive-Fast-Fourier-Transformation/</url>
      
        <content type="html"><![CDATA[<p>Fast Fourier Transform can be used to evaluate a degree $n-1$ polynomial at $n$ distinct points in time complexity $O(n log n)$. But it’s only possible when the $n$ points are $n$th roots of unity (and so form a cyclic multiplicative group of order $n$ ) where $n$ is a power of 2 or a product of small primes. They are based on the factorization of the polynomial $x^n-1$, corresponding to the subgroup structure of the multiplicative group of order $n$.</p><p>Hence, multiplicative FFTs may have little advantage over straightforward evaluation of the $n$ polynomial when over $\mathbb{F}_{2^k}$, because $2^k-1$ is not product of small primes.</p><p>Additive fast Fourier transforms over finite field evaluate a polynomial at each roots of polynomial $x^n-x$ (each of the powers of a primitive $(n-1)$th root of unity and the zero element)</p><h2 id="Taylor-Expansion"><a href="#Taylor-Expansion" class="headerlink" title="Taylor Expansion"></a>Taylor Expansion</h2><p>First, we want to know how to compute a generalized Taylor expansion of polynomial.</p><p>Let $\mathbb{F}$ be any field of characteristic two, $t&gt;1$ any integer, and $f(x) \in \mathbb{F}[x]$ of degree $&lt;n$. We want to find polynomials $h_0(x), h_1(x), \ldots, h_{m-1}(x) \in \mathbb{F}[x]$ such that</p><script type="math/tex; mode=display">\begin{aligned}f(x)=h_0(x)+h_1(x) \cdot\left(x^t-x\right)+ & \cdots \\& +h_{m-1}(x) \cdot\left(x^t-x\right)^{m-1}\end{aligned}</script><p>where $m = \left \lceil n/t \right \rceil$ and $\deg h_i &lt; t$</p><p>First we find $k$ be such that</p><script type="math/tex; mode=display">2^k < \frac{n}{t} \leq 2^{k+1}</script><p>Write $f(x)$ as $f(x)=f_0(x)+x^{t 2^k}\left(f_1(x)+x^{(t-1) 2^k} f_2(x)\right)$ where</p><script type="math/tex; mode=display">\begin{aligned}& \operatorname{deg} f_0<t 2^k, \\& \operatorname{deg} f_1<\min \left(n-t 2^k,(t-1) 2^k\right) \leq(t-1) 2^k, \\& \operatorname{deg} f_2<2^k\end{aligned}</script><p>then we have </p><script type="math/tex; mode=display">\begin{aligned}f(x)=f_0(x)+ & x^{2^k}\left(f_1(x)+f_2(x)\right) \\& +\left(x^t-x\right)^{2^k}\left(f_1(x)+f_2(x)+x^{(t-1) 2^k} f_2(x)\right) .\end{aligned}</script><p>Set $h(x)=f_1(x)+f_2(x)$, and</p><script type="math/tex; mode=display">g_0(x)=f_0(x)+x^{2^k} h(x), \quad g_1(x)=h(x)+x^{(t-1) 2^k} f_2(x)</script><p>Then</p><script type="math/tex; mode=display">f(x)=g_0(x)+g_1(x)\left(x^t-x\right)^{2^k}</script><p>Since $\operatorname{deg} f_1&lt;(t-1) 2^k$ and $\operatorname{deg} f_2&lt;2^k$, we have $\operatorname{deg} h&lt;$ $(t-1) 2^k$, so</p><script type="math/tex; mode=display">\operatorname{deg} g_0<t 2^k, \quad \operatorname{deg} g_1<n-t 2^k</script><p>Therefore</p><script type="math/tex; mode=display">\mathrm{T}(f, n, t)=\left(\mathrm{T}\left(g_0, t 2^k, t\right), \mathrm{T}\left(g_1, n-t 2^k, t\right)\right)</script><p><img src="/imgs/afft/Pasted image 20250315163054.png" alt="alt text"></p><h2 id="FFT-over-mathbb-F-2-m-arbitrary-m"><a href="#FFT-over-mathbb-F-2-m-arbitrary-m" class="headerlink" title="FFT over $\mathbb{F}_{2^m}$:  arbitrary $m$"></a>FFT over $\mathbb{F}_{2^m}$:  arbitrary $m$</h2><p>Let $\mathbb{F}$ be any field of characteristic two. Assume that $\beta_1, \ldots, \beta_m \in \mathbb{F}$ are linearly independent over $\mathbb{F}_2$. Let $B$ be the subspace spanned by $\beta_i$ ‘s over $\mathbb{F}_2$, namely</p><script type="math/tex; mode=display">\begin{aligned}B & =\left\langle\beta_1, \ldots, \beta_m\right\rangle \\& =\left\{a_1 \beta_1+\cdots+a_m \beta_m: a_1, \ldots, a_m \in \mathbb{F}_2\right\} .\end{aligned}</script><p>We order the elements of $B$ as follows:</p><script type="math/tex; mode=display">B[i] = a_1\beta_1 + a_2\beta_2+\dots + a_m \beta_m</script><p>where each $a_j = 0 \text{ or } 1$. Then</p><script type="math/tex; mode=display">\operatorname{FFT}(f, m, B)=(f(B[0]), f(B[1]), \ldots, f(B[n-1])) .</script><p>Define</p><script type="math/tex; mode=display">\begin{aligned}&\gamma_i=\beta_i \cdot \beta_m^{-1}, \quad 1 \leq i \leq m-1\\\end{aligned}</script><p>and</p><script type="math/tex; mode=display">\begin{aligned}G & =\left\langle\gamma_1, \ldots, \gamma_{m-1}\right\rangle \\& =\left\{a_1 \gamma_1+\cdots+a_{m-1} \gamma_{m-1}: a_1, \ldots, a_{m-1} \in \mathbb{F}_2\right\} .\end{aligned}</script><p>Let $g(x) = f(\beta_m x)$, then evaluating $f(x)$ over $B$ is the same as evaluating $g(x)$ over $B\cdot \beta_m^{-1}=G\cup (G+1)$ where $G+1=\{\alpha+1: \alpha \in G\}$.</p><script type="math/tex; mode=display">\begin{aligned}G & =\left\langle\gamma_1, \ldots, \gamma_{m-1}\right\rangle \\& =\left\{a_1 \gamma_1+\cdots+a_{m-1} \gamma_{m-1}: a_1, \ldots, a_{m-1} \in \mathbb{F}_2\right\}\\ &=\left\{a_1 \beta_1\beta_m^{-1}+\cdots+a_{m-1} \beta_{m-1}\beta_{m-1}^{-1} + a_m\beta_m\beta_m^{-1}: a_1, \ldots, a_{m-1} \in \mathbb{F}_2, a_m=0\right\}\\ \end{aligned}</script><p>and</p><script type="math/tex; mode=display">\begin{aligned}G+1& = \left\{a_1 \beta_1\beta_m^{-1}+\cdots+a_{m-1} \beta_{m-1}\beta_{m-1}^{-1} + a_m\beta_{m}\beta_m^{-1}: a_1, \ldots, a_{m-1} \in \mathbb{F}_2,a_m=1\right\}\\ \end{aligned}</script><p>Then we can get</p><script type="math/tex; mode=display">\begin{aligned}\operatorname{FFT}(f, m, B) & \\& =(\operatorname{FFT}(g, m-1, G), \operatorname{FFT}(g, m-1, G+1))\end{aligned}</script><p>We need to show how to compute $\operatorname{FFT}(g, G)$ and $\operatorname{FFT}(g, G+1)$. Define</p><script type="math/tex; mode=display">\delta_i=\gamma_i^2-\gamma_i, \quad 1 \leq i \leq m-1</script><p>and</p><script type="math/tex; mode=display">\begin{aligned}D & =\left\langle\delta_1, \ldots, \delta_{m-1}\right\rangle \\& =\left\{a_1 \delta_1+\cdots+a_{m-1} \delta_{m-1}: a_1, \ldots, a_{m-1} \in \mathbb{F}_2\right\} .\end{aligned}</script><p>Since $\gamma_1, \ldots, \gamma_{m-1}$ and 1 are linearly independent over $\mathbb{F}_2$, the new elements $\delta_1, \ldots, \delta_{m-1}$ are linearly independent over $\mathbb{F}_2$, so $D$ is a subspace of $\mathbb{F}$ of size $k=2^{m-1}=n / 2$. For each $\alpha=a_1 \gamma_1+\cdots+a_{m-1} \gamma_{m-1} \in G$, let</p><script type="math/tex; mode=display">\alpha^*=\alpha^2-\alpha=a_1 \delta_1+\cdots+a_{m-1} \delta_{m-1} \in D</script><p>Then we have</p><script type="math/tex; mode=display">G[i]^*=D[i], \quad 0 \leq i<k</script><p>where $G[i]$ and $D[i]$ are the $i$ th elements of $G$ and $D$, respectively, which are ordered according to the binary representation of $i$ in a similar fashion as that described above for $B$.</p><p>Suppose the Taylor expansion of $g(x)$ at $x^2-x$ is</p><script type="math/tex; mode=display">g(x)=\sum_{i=0}^{k-1}\left(g_{i 0}+g_{i 1} x\right) \cdot\left(x^2-x\right)^i</script><p>where $g_{i j} \in \mathbb{F}$. Let</p><script type="math/tex; mode=display">g_0(x)=\sum_{i=0}^{k-1} g_{i 0} \cdot x^i, \quad \text { and } g_1(x)=\sum_{i=0}^{k-1} g_{i 1} \cdot x^i</script><p>For any $\alpha \in G$ and $b \in \mathbb{F}_2$, since $(\alpha+b)^2-(\alpha+b)=\alpha^*$, we have,</p><script type="math/tex; mode=display">g(\alpha+b)=\left(g_0\left(\alpha^*\right)+\alpha \cdot g_1\left(\alpha^*\right)\right)+b g_1\left(\alpha^*\right) .</script><p>Hence the FFT of $g(x)$ can be obtained from those of $g_0(x)$ and $g_1(x)$ as follows. Let the FFT of $g_0(x)$ and $g_1(x)$ over $D$ be</p><script type="math/tex; mode=display">\begin{aligned}& \operatorname{FFT}\left(g_0, m-1, D\right)=\left(u_0, u_1, \ldots, u_{k-1}\right), \\& \operatorname{FFT}\left(g_1, m-1, D\right)=\left(v_0, v_1, \ldots, v_{k-1}\right)\end{aligned}</script><p>where $u_i=g_0(D[i])$ and $v_i=g_1(D[i]), 0 \leq i&lt;k$. Then the equation (5) implies that</p><script type="math/tex; mode=display">\operatorname{FFT}(g, m-1, G)=\left(w_0, w_1, \ldots, w_{k-1}\right)</script><p>where $w_i=u_i+G[i] \cdot v_i$ for $0 \leq i&lt;k$, and</p><script type="math/tex; mode=display">\begin{aligned}& \operatorname{FFT}(g, m-1, G+1) \\& \quad=\operatorname{FFT}(g, m-1, G)+\operatorname{FFT}\left(g_1, m-1, D\right) .\end{aligned}</script><p><img src="/imgs/afft/Pasted image 20250315175530.png" alt="alt text"></p><h2 id="FFT-over-mathbb-F-2-m-m-a-power-of-two"><a href="#FFT-over-mathbb-F-2-m-m-a-power-of-two" class="headerlink" title="FFT over $\mathbb{F}_{2^m}$:  $m$ a power of two"></a>FFT over $\mathbb{F}_{2^m}$:  $m$ a power of two</h2><p>Todo</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1]  <a href="https://ieeexplore.ieee.org/iel5/18/5625612/05625613.pdf"> Additive Fast Fourier Transforms Over Finite Fields</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Short, Invertible Elements in Partially Splitting Cyclotomic Rings and Applications to Lattice-Based Zero-Knowledge Proofs</title>
      <link href="/2025/03/01/Short%20Invertible%20Elements%20in%20Partially%20Splitting%20Cyclotomic%20Rings%20and%20Applications%20to%20Lattice-Based%20Zero-Knowledge%20Proofs/"/>
      <url>/2025/03/01/Short%20Invertible%20Elements%20in%20Partially%20Splitting%20Cyclotomic%20Rings%20and%20Applications%20to%20Lattice-Based%20Zero-Knowledge%20Proofs/</url>
      
        <content type="html"><![CDATA[<p>本篇论文主要介绍了在ZK场景下所使用的Cyclotomic Ring，通过限制素数$p$的选取，从而实现Challenge Set $\mathcal{C}$ 中的元素可逆，从而帮助Ajtai Commitment实现Proof of Knowledge。</p><p>首先简要介绍一下Ajtai Commitment<br><img src="/imgs/Short Invertible Elements/ajtai.png" alt="alt text"></p><p>由此可知，如果我们能保证 $\mathcal{C}-\mathcal{C}$ 中的元素可逆，就能保证其Proof of Knowledge的性质</p><p>接下来给出结论：<br><img src="/imgs/Short Invertible Elements/image.png" alt="alt text"></p><p>其中 $p=2k+1 \pmod{4k}$的条件是为了保证能够进行分解</p><script type="math/tex; mode=display">X^n+1 \equiv \prod_{j=1}^k\left(X^{n / k}-r_j\right) \quad(\bmod p)</script><p>之后通过安全参数和Challenge Set的选取，可以获得$\left | y \right |_\infty$ 的值的大小，再通过$k$即可反推出所需要使用的 素数$p$的大小。</p><p>其中关于分圆多项式分解等内容的证明还是相对比较有趣，值得一读</p><script type="math/tex; mode=display">\Phi_m(X) = \Phi_\delta(m)(X^{(m/\delta(m))})</script><p>其中</p><ul><li>$\Phi_m(X)$是第$m$个循环多项式</li><li>$\delta(m)$是$m$的根式(radical)，即$m$的不重复素因子的乘积</li></ul><p>将$m$分解为$m = p_1^{e_1} * p_2^{e_2} * \dots * p_r^{e_r}$，<br>其中 $p_i$ 是不同的素数，那么 $\delta(m) = p_1*p_2*\dots*p_r$ ，是 $m$ 的无平方因子部分。<br>要证明 $\Phi_m(X) = \Phi_\delta(m)(X^{(m/\delta(m))})$ ，我们可以证明这两个多项式有相同的根。</p><p>设$\zeta_m$为本原$m$次单位根。根据循环多项式的定义：</p><p>$\Phi_m(X) = ∏_{(j,m)=1} (X - \zeta_m^j)$</p><p>其中$(j,m)=1$表示$j$与$m$互素。</p><p>我们需要证明的关键是：$X^{(m/\delta(m))} - \zeta_{\delta(m)}^j = 0$的解集合与本原$m$次单位根集合是相同的。</p><h3 id="首先证明-alpha是m次单位根"><a href="#首先证明-alpha是m次单位根" class="headerlink" title="首先证明\alpha是m次单位根"></a>首先证明\alpha是m次单位根</h3><p>已知$\alpha^{(m/\delta(m))} = \zeta$，且$\zeta$是本原$\delta(m)$次单位根，因此：</p><p>$\zeta^{\delta(m)} = 1$</p><p>所以： $\alpha^m = \alpha^{(m/\delta(m)·\delta(m))} = \zeta^{\delta(m)} = 1$<br>这证明了$\alpha$是$m$次单位根。</p><h3 id="证明-alpha-的阶恰好等于m"><a href="#证明-alpha-的阶恰好等于m" class="headerlink" title="证明$\alpha$的阶恰好等于m"></a>证明$\alpha$的阶恰好等于m</h3><p>假设$\alpha$的阶是$d$，即$d$是使得$\alpha^d = 1$的最小正整数。因为$\alpha^m = 1$，所以$d$必须整除$m$（记为$d|m$）。</p><p>我们需要证明$d = m$。通过反证法，假设$d &lt; m$。</p><p>因为$\alpha^d = 1$，我们可以推导：</p><p>$(\alpha^{(m/\delta(m))})^{(d·\delta(m)/m)} = \zeta^{(d·\delta(m)/m)} = 1$</p><p>由于$\zeta$是本原$\delta(m)$次单位根，上式表明$\delta(m)$必须整除$(d·\delta(m)/m)$，即：$\delta(m) |(d·\delta(m)/m)$</p>]]></content>
      
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Post Quantum Cryptography: NTRU</title>
      <link href="/2024/11/05/Post-Quantum-Cryptography-NTRU/"/>
      <url>/2024/11/05/Post-Quantum-Cryptography-NTRU/</url>
      
        <content type="html"><![CDATA[<h2 id="Preliminary"><a href="#Preliminary" class="headerlink" title="Preliminary"></a>Preliminary</h2><h3 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h3><p>First, we begin by fixing an integer $N \ge 1$ and two moduli $p$ and $q$, and we let $R, R_p$, and $R_q$ be the convolution polynomial rings</p><script type="math/tex; mode=display">R=\frac{\mathbb{Z}[x]}{\left(x^N-1\right)}, \quad R_p=\frac{(\mathbb{Z} / p \mathbb{Z})[x]}{\left(x^N-1\right)}, \quad R_q=\frac{(\mathbb{Z} / q \mathbb{Z})[x]}{\left(x^N-1\right)}</script><p>As usual, we may view a polynomial $\boldsymbol{a}(x) \in R$ as an element of $R_p$ or $R_q$ by reducing its coefficients modulo $p$ or $q$. In the other direction, we use center-lifts to move elements from $R_p$ or $R_q$ to $R$. We make various assumptions on the parameters $N, p$ and $q$, in particular we require that $N$ be prime and that $\operatorname{gcd}(N, q)=\operatorname{gcd}(p, q)=1$. </p><h3 id="Ternary-Polynomial"><a href="#Ternary-Polynomial" class="headerlink" title="Ternary Polynomial"></a>Ternary Polynomial</h3><p>For any positive integers $d_1$ and $d_2$, we let</p><script type="math/tex; mode=display">\mathcal{T}\left(d_1, d_2\right)=\left\{\begin{aligned}&\boldsymbol{a}(x) \text { has } d_1 \text { coefficients equal to } 1, \\\boldsymbol{a}(x) \in R:\quad &\boldsymbol{a}(x) \text { has } d_2 \text { coefficients equal to }-1, \\&\boldsymbol{a}(x) \text { has all other coefficients equal to } 0\end{aligned}\right\} .</script><p>Polynomials in $\mathcal{T}\left(d_1, d_2\right)$ are called ternary (or trinary) polynomials. They are analogous to binary polynomials, which have only 0’s and 1’s as coefficients.</p><h3 id="NTRU-Encryption"><a href="#NTRU-Encryption" class="headerlink" title="NTRU Encryption"></a>NTRU Encryption</h3><p>We are now ready to describe NTRUEncrypt. Alice (or some trusted authority) chooses public parameters ( $N, p, q, d$ ) satisfying: (1) $\gcd(p,q)=\gcd(N,q)=1$;(2)$q&gt;(6d+1)p$ . Alice’s private key consists of two randomly chosen polynomials</p><script type="math/tex; mode=display">\boldsymbol{f}(x) \in \mathcal{T}(d+1, d) \quad \text { and } \quad \boldsymbol{g}(x) \in \mathcal{T}(d, d)</script><p>Alice computes the inverses</p><script type="math/tex; mode=display">\boldsymbol{F}_q(x)=\boldsymbol{f}(x)^{-1} \quad \text { in } R_q \quad \text { and } \quad \boldsymbol{F}_p(x)=\boldsymbol{f}(x)^{-1} \quad \text { in } R_p .</script><p>Alice next computes</p><script type="math/tex; mode=display">\boldsymbol{h}(x)=\boldsymbol{F}_q(x) \star \boldsymbol{g}(x) \quad \text { in } R_q .</script><p>The polynomial $\boldsymbol{h}(x)$ is Alice’s public key. Her private key, which she’ll need to decrypt messages, is the pair $\left(\boldsymbol{f}(x), \boldsymbol{F}_p(x)\right)$. Alternatively, Alice can just store $\boldsymbol{f}(x)$ and recompute $\boldsymbol{F}_p(x)$ when she needs it.</p><p>Bob’s plaintext is a polynomial $\boldsymbol{m}(x) \in R$ whose coefficients satisfy $-\frac{1}{2} p&lt;$ $m_i \leq \frac{1}{2} p$, i.e., the plaintext $\boldsymbol{m}$ is a polynomial in $R$ that is the center-lift of a polynomial in $R_p$. Bob chooses a random polynomial (a random element) $\boldsymbol{r}(x) \in \mathcal{T}(d, d)$ and computes</p><script type="math/tex; mode=display">\boldsymbol{e}(x) \equiv p \boldsymbol{h}(x) \star \boldsymbol{r}(x)+\boldsymbol{m}(x) \quad(\bmod q)</script><p>Bob’s ciphertext $\boldsymbol{e}(x)$ is in the ring $R_q$.<br>On receiving Bob’s ciphertext, Alice starts the decryption process by computing</p><script type="math/tex; mode=display">\boldsymbol{a}(x) \equiv \boldsymbol{f}(x) \star \boldsymbol{e}(x) \quad(\bmod q) .</script><p>She then center lifts $\boldsymbol{a}(x)$ to an element of $R$ and does a $\bmod p$ computation,</p><script type="math/tex; mode=display">\boldsymbol{b}(x) \equiv \boldsymbol{F}_p(x) \star \boldsymbol{a}(x) \quad(\bmod p) .</script><p>Assuming that the parameters have been chosen properly, we now verify that the polynomial $\boldsymbol{b}(x)$ is equal to the plaintext $\boldsymbol{m}(x)$.</p><h2 id="NTRUEncrypt-the-NTRU-public-key-cryptosystem"><a href="#NTRUEncrypt-the-NTRU-public-key-cryptosystem" class="headerlink" title="NTRUEncrypt: the NTRU public key cryptosystem"></a>NTRUEncrypt: the NTRU public key cryptosystem</h2><p><img src="/imgs/NTRU.png" alt="alt text"></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] Hoffstein J, Pipher J, Silverman J H, et al. An Introduction to Cryptography[M]. Springer New York, 2014.</p><p>[2] <a href="https://0xffff.one/d/1424/5">https://0xffff.one/d/1424/5</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Post Quantum Cryptography </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The Fujisaki-Okamoto transform</title>
      <link href="/2024/11/04/The-Fujisaki-Okamoto-transform/"/>
      <url>/2024/11/04/The-Fujisaki-Okamoto-transform/</url>
      
        <content type="html"><![CDATA[<h2 id="Syntax-of-Encryption-Schemes"><a href="#Syntax-of-Encryption-Schemes" class="headerlink" title="Syntax of Encryption Schemes"></a>Syntax of Encryption Schemes</h2><p>Recall the syntax of asymmetric and symmetric encryption schemes, basically following [2],[3]</p><h3 id="Asymmetric-Encryption"><a href="#Asymmetric-Encryption" class="headerlink" title="Asymmetric Encryption"></a>Asymmetric Encryption</h3><p>An asymmetric (aka public-key) encryption scheme is given by a triple of algorithms, $\Pi=(\mathcal{K}, \mathcal{E}, \mathcal{D})$, where for every sufficiently large $k \in \mathbb{N}$,</p><ul><li>$\mathcal{K}$, the key-generation algorithm, is a probabilistic polynomial-time (in $k$ ) algorithm which on input $1^k$ outputs a pair of strings, $(p k, s k)$, called the public and secret keys, respectively. This experiment is written as $(p k, s k) \leftarrow \mathcal{K}\left(1^k\right)$.</li><li>$\mathcal{E}$, the encryption algorithm, is a probabilistic polynomial-time (in $k$ ) algorithm that takes public key $p k$ and message $x \in$ MSP, draws coins $r$ uniformly from coin space COIN, and produces ciphertext $y:=\mathcal{E}_{p k}(x ; r)$. This experiment is written as $y \leftarrow \mathcal{E}_{p k}(x)$. The message and coin spaces, MSP and COIN, are uniquely determined by $p k$.</li><li>$\mathcal{D}$, the decryption algorithm, is a deterministic polynomial-time (in $k$ ) algorithm that takes secret key $s k$ and ciphertext $y \in\{0,1\}^*$, and returns message $x:=\mathcal{D}_{s k}(y)$.</li></ul><p>We require that an asymmetric encryption scheme should satisfy the following correctness condition: For every sufficiently large $k \in \mathbb{N}$, every ( $p k, s k$ ) generated by $\mathcal{K}\left(1^k\right)$ and every $x \in$ MSP, we always have $\mathcal{D}_{s k}\left(\mathcal{E}_{p k}(x)\right)=x$.</p><h3 id="Symmetric-Encryption"><a href="#Symmetric-Encryption" class="headerlink" title="Symmetric Encryption"></a>Symmetric Encryption</h3><p>A symmetric (aka private-key) encryption scheme is given by a pair of algorithms, $\Pi=$ $(\mathcal{E}, \mathcal{D})$, where for every sufficiently large $k \in \mathbb{N}$,</p><ul><li>$\mathcal{E}$, the encryption algorithm, is a probabilistic polynomial-time (in $k$ ) algorithm that takes secret key $a \in \operatorname{KSP}$ and message $x \in$ MSP, draws coins $r$ uniformly from coin space COIN, and produces ciphertext $y:=\mathcal{E}_a(x ; r)$. This experiment is written as $y \leftarrow \mathcal{E}_a(x)$. The key, message, and coin spaces, KSP, MSP and COIN, are uniquely determined by $k$.</li><li>$\mathcal{D}$, the decryption algorithm, is a deterministic polynomial-time (in $k$ ) algorithm that takes secret key $a \in \operatorname{KSP}$ and ciphertext $y \in\{0,1\}^*$, and outputs message $x:=$ $\mathcal{D}_a(y)$.</li></ul><p>We require that a symmetric encryption scheme should satisfy the correctness condition: For every sufficiently large $k \in \mathbb{N}$, every $a \in \operatorname{KSP}$ and every $x \in$ MSP, we always have $\mathcal{D}_a\left(\mathcal{E}_a(x)\right)=x$</p><h2 id="Fujisaki-Okamoto-Transform"><a href="#Fujisaki-Okamoto-Transform" class="headerlink" title="Fujisaki-Okamoto Transform"></a>Fujisaki-Okamoto Transform</h2><p>Let $\Pi^{\text {asy }}=\left(\mathcal{K}^{\text {asy }}, \mathcal{E}^{\text {asy }}, \mathcal{D}^{\text {asy }}\right)$ and $\Pi^{\text {sy }}=\left(\mathcal{E}^{\text {sy }}, \mathcal{D}^{\text {sy }}\right)$ be asymmetric and symmetric encryption schemes, respectively, $(p k, s k)$ be a pair of public and secret keys generated by $\mathcal{K}^{\text {asy }}\left(1^k\right)$, MSP $^{\text {asy }}$ and COIN ${ }^{\text {asy }}$ be the message and coin spaces of $\Pi^{\text {asy }}$ with respect to $p k$, and $\mathrm{KSP}^{\text {sy }}$ and $\mathrm{MSP}^{\text {sy }}$ be the key and message spaces of $\Pi^{\text {sy }}$ (with respect $k$ ). We define two hash functions.</p><script type="math/tex; mode=display">G:\{0,1\}^* \rightarrow \operatorname{KSP}^{\text {sy }} \quad \text { and } \quad H:\{0,1\}^* \times\{0,1\}^* \rightarrow \operatorname{COIN}^{\text {asy }}</script><p>Given $\Pi^{\text {asy }}$ and $\Pi^{\text {sy }}$, we construct a hybrid encryption scheme $\Pi^{\text {hy }}=\left(\mathcal{K}^{\text {hy }}, \mathcal{E}^{\text {hy }}, \mathcal{D}^{\text {hy }}\right)$. We write COIN ${ }^{\text {hy }}$ and MSP ${ }^{\text {hy }}$ to denote the coin and message spaces of $\Pi^{\mathrm{hy}}$. This hybrid encryption scheme is specified as follows:</p><p><strong>Key-generation:</strong> $\mathcal{K}^{\text {hy }}$, the key-generation algorithm, takes $1^k$ as input. It selects $(p k, s k) \leftarrow \mathcal{K}^{\text {asy }}\left(1^k\right)$ and returns $(p k, s k)$ as the output of $\mathcal{K}^{\text {hy }}\left(1^k\right)$. We write the experiment as $(p k, s k) \leftarrow \mathcal{K}^{\text {hy }}\left(1^k\right)$.</p><p><strong>Encryption:</strong> $\mathcal{E}^{\text {hy }}$, the encryption algorithm, takes public key $p k$ and message $m \in$ $\mathrm{MSP}^{\text {hy }}\left(:=\mathrm{MSP}^{\mathrm{sy}}\right)$ as input. It selects $\sigma \leftarrow_R \operatorname{COIN}^{\text {hy }}\left(:=\mathrm{MSP}^{\text {asy }}\right)$, computes $c \leftarrow$ $\mathcal{E}_a^{\text {sy }}(m)$, where $a:=G(\sigma)$, and computes $e:=\mathcal{E}_{p k}^{\text {asy }}(\sigma ; h)$ where $h:=H(\sigma, c)$. It finally outputs $e | c$ as $\mathcal{E}_{p k}^{\text {hy }}(m ; \sigma)$. As described above, the coin and message spaces of $\Pi^{\text {hy }}$ with respect to $p k$ are defined as COIN ${ }^{\text {hy }}:=$ MSP $^{\text {asy }}$ and MSP ${ }^{\text {hy }}:=\mathrm{MSP}^{\text {sy }}$.</p><p><strong>Decryption</strong> $\mathcal{D}^{\text {hy }}$, the decryption algorithm, takes secret key $s k$ and ciphertext $e | c \in$ $\{0,1\}^*$ as input. It runs as follows.</p><ol><li>Parse $e | c$ appropriately as $(e, c)$; otherwise, output $\varepsilon$ and halt.</li><li>Compute $\hat{\sigma}:=\mathcal{D}_{s k}^{\text {asy }}(e)$.</li><li>If $\hat{\sigma} \in \operatorname{COIN}^{\mathrm{hy}}$,<br>(a) then compute $\hat{a}:=G(\hat{\sigma})$.<br>(b) otherwise, set $\mathcal{D}_{s k}^{\text {hy }}(e | c):=\varepsilon$ and go to Step 6.</li><li>Set $\hat{h}:=H(\hat{\sigma}, c)$.</li><li>If $e=\mathcal{E}_{p k}^{\text {asy }}(\hat{\sigma} ; \hat{h})$,<br>(a) then set $\mathcal{D}_{s k}^{\mathrm{hy}}(e | c):=\mathcal{D}_{\hat{a}}^{\mathrm{sy}}(c)$.<br>(b) otherwise, $\mathcal{D}_{s k}^{\mathrm{hy}}(e | c):=\varepsilon$.</li><li>Return $\mathcal{D}_{s k}^{\text {hy }}(e | c)$.</li></ol><h2 id="Well-Spread-Encryption"><a href="#Well-Spread-Encryption" class="headerlink" title="Well-Spread Encryption"></a>Well-Spread Encryption</h2><p>Let $|X|$ be the infinity norm of probability space $X$ on a finite set $S$, i.e., $|X|=$ $\max _{a \in \mathcal{S}}\{\operatorname{Pr}[x \leftarrow X: x=a]\}$. The min-entropy of $X$ is $-\log |X|$.</p><p>Definition 5.2 ( $\gamma$-spread). Let $\Pi=(\mathcal{K}, \mathcal{E}, \mathcal{D})$ be an asymmetric encryption scheme. For $p k$ and $x \in$ MSP, define the min-entropy of $\mathcal{E}_{p k}(x)$ by $\gamma(p k, x)=-\log \left|\mathcal{E}_{p k}(x)\right|$, where</p><script type="math/tex; mode=display">\left\|\mathcal{E}_{p k}(x)\right\|=\max _{y \in\{0,1\}^*} \operatorname{Pr}\left[h \leftarrow_R \text { COIN : } y=\mathcal{E}_{p k}(x, h)\right]</script><p>We say that $\Pi$ is $\gamma$-spread (for $k \in \mathbb{N}$ ), if, for every $p k$ generated by $\mathcal{K}\left(1^k\right)$ and $x \in \operatorname{MSP}$, $\gamma(p k, x) \geq \gamma$. In particular, we say that $\Pi$ is well-spread in $k$ if $\gamma=\omega(\log (k))$.</p><p><strong>Intuition：</strong> $\gamma(p k, x)$ measures the uncertainty of the ciphertext(min-entropy) generated by $\mathcal{E}_{p k}$ on input $x$. The probability of the most possible ciphertext for all possible $x$ is at most $2^{-\gamma}$, which means any plaintext in the message space has at least $2^{\omega(\log k)}$ possible ciphertexts(called $\omega(\log k)$-spread).(other ciphertext for a fixed plaintext is less than $2^{-\gamma}$)</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] <a href="https://www.google.com/url?sa=t&amp;source=web&amp;rct=j&amp;opi=89978449&amp;url=https://courses.grainger.illinois.edu/cs598dk/fa2019/Files/fujisaki_okamoto.pdf&amp;ved=2ahUKEwjnlLnfxMSJAxUnhq8BHR7jNC0QFnoECBYQAQ&amp;usg=AOvVaw3Ihrhb-K-5SFWMKjGl6fF_">Secure Integration of Asymmetric and Symmetric Encryption Schemes</a></p><p>[2] M. Bellare, A. Desai, D. Pointcheval, P. Rogaway, Relations among notions of security for public-key encryption schemes, in Advances in Cryptology—CRYPTO’98, ed. by H. Krawczyk. Lecture Notes in Computer Science, vol. 1462 (Springer, Berlin, 1998), pp. 26–45</p><p>[3] S. Goldwasser, S. Micali, Probabilistic encryption. J. Comput. Syst. Sci. 28, 270–299 (1984)</p>]]></content>
      
      
      
        <tags>
            
            <tag> Cryptography </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sum-Check Protocol</title>
      <link href="/2024/10/31/Sum-Check-Protocol/"/>
      <url>/2024/10/31/Sum-Check-Protocol/</url>
      
        <content type="html"><![CDATA[<p>Suppose there is an $\mu$-variate low-degree polynomial, $\mathcal{G}: \mathbb{F}^\mu \rightarrow \mathbb{F}$ where the degree of each variable in $\mathcal{G}$ is at most $\ell$. Suppose that a verifier $\mathcal{V}_{S C}$ is <strong>interested in checking a claim of the following form by an untrusted prover</strong> $\mathcal{P}_{S C}$ or <strong>the computationally bounded verifier wants to delegate the heavy computation to a unbounded prover</strong> :</p><script type="math/tex; mode=display">T=\sum_{x_1 \in\{0,1\}} \sum_{x_2 \in\{0,1\}} \ldots \sum_{x_\mu \in\{0,1\}} \mathcal{G}\left(x_1, x_2, \ldots, x_\mu\right)</script><p>First, we can analyze the cost of the above computation. The number of terms in the above sum is $2^\mu$. The degree of the polynomial $\mathcal{G}$ is $\ell$ in each variable. Therefore, the degree of the polynomial $\mathcal{G}$ is at most $\mu \cdot \ell$. The cost of evaluating the polynomial $\mathcal{G}$ at a point is $O(\mu \cdot \ell)$. Therefore, the cost of evaluating the above sum is $O(2^\mu \cdot \mu \cdot \ell)$. It’s unaffordable to compute the above sum by the verifier $\mathcal{V}_{S C}$ itself.</p><p>By using Sum-Check Protocol, the verifier can reduce the cost to just calculate a random point of the polynomial $\mathcal{G}$ and sample some random points. The complexity of the protocol is $O(\mu \cdot \ell)$.</p><p><img src="/imgs/sumcheck.png" alt="alt text"></p><p>We denote the sum-check protocol as $b \leftarrow\left\langle\mathcal{P}_{S C}, \mathcal{V}_{S C}(r)\right\rangle(\mathcal{G}, \mu, \ell, T)$. For any $\mu$-variate polynomial $\mathcal{G}$ with degree at most $\ell$ in each variable, the following properties hold.</p><ul><li>Completeness. If $T=\sum_{x \in\{0,1\}^\mu} \mathcal{G}(x)$, then for a correct $\mathcal{P}_{S C}$ and for all $r \in\{0,1\}^*$, $\operatorname{Pr}\left\{\left\langle\mathcal{P}_{S C}(\mathcal{G}), \mathcal{V}_{S C}(r)\right\rangle(\mu, \ell, T)=1\right\}=1$.</li><li>Soundness. If $T \neq \sum_{x \in\{0,1\}^\mu} \mathcal{G}(x)$, then for any $\mathcal{P}_{S C}^{\star}$ and for all $r \in\{0,1\}^*$, $\operatorname{Pr}_r\left\{\left\langle\mathcal{P}_{S C}^{\star}(\mathcal{G}), \mathcal{V}_{S C}(r)\right\rangle(\mu, \ell, T)=1\right\} \leq \ell \cdot \mu /|\mathbb{F}|$.</li><li>Succinctness. The communication between $\mathcal{P}_{S C}$ and $\mathcal{V}_{S C}$ is $O(\mu \cdot \ell)$ elements of $\mathbb{F}$.</li></ul><h3 id="Proof-of-Soundness"><a href="#Proof-of-Soundness" class="headerlink" title="Proof of Soundness"></a>Proof of Soundness</h3><p>In this section, we will prove the soundness of the sum-check protocol. We will show that if $T \neq \sum_{x \in\{0,1\}^\mu} \mathcal{G}$, then for any $\mathcal{P}_{S C}^{\star}$ and for all $r \in\{0,1\}^*$, $\operatorname{Pr}_r\left\{\left\langle\mathcal{P}_{S C}(\mathcal{G^\star}), \mathcal{V}_{S C}(r)\right\rangle(\mu, \ell, T)=1\right\} \leq \ell \cdot \mu /|\mathbb{F}|$.</p><!-- Assume the polynomail satisfies the above condition is $\mathcal{G}(x)$.  --><p>We can prove it by induction. </p><p>The base case is $\mu=1$: Prover’s only message is a degree-$\ell$ polynomial $\mathcal{G}_1(x_1)$, and the verifier’s only message is a random point $r_1 \in \mathbb{F}$.</p><p>The prover can forge a polynomial satisfy $T=\mathcal{G}_1(0)+\mathcal{G}_1(1)$. But the verifier checks the following equation:</p><script type="math/tex; mode=display">\mathcal{G}_1(r_1)= \mathcal{G}(r_1)</script><p>By the Schwartz-Zippel lemma, the probability that the above equation holds is at most $\ell/|\mathbb{F}|$.</p><p>Assume the statement holds for $\mu-1$. </p><p>Let  $h_1\left(X_1\right)=\sum_{x_2, \ldots, x_v \in\{0,1\}^{\nu-1}} \mathcal{G}\left(X_1, x_2, \ldots, x_v\right)$. </p><p>Suppose $\mathcal{P}$ sends a polynomial $\mathcal{G}_1$ satisfying $T=\mathcal{G}_1(0)+\mathcal{G}_1(1)$ and $\mathcal{G}_1(X_1)\not =h_1(X_1)$. Then because the degree of the degree of $\mathcal{G}_1-h_1$ is at most $\ell$, $\mathcal{G}_1(r_1)=h_1(r_1)$ with probability at most $\ell/|\mathbb{F}|$.</p><p>Conditioned on $\mathcal{G}_1(r_1)=h_1(r_1)$, the verifier need to checks:</p><script type="math/tex; mode=display">\mathcal{G}_1\left(r_1\right)=\sum_{\left(x_2, \ldots, x_v\right) \in\{0,1\}^{v-1}} \mathcal{G}\left(r_1, x_2, \ldots, x_v\right) .</script><p>By the induction hypothesis, the probability that the above equation holds is at most $\ell \cdot (\mu-1) /|\mathbb{F}|$.</p><p>Therefore, the probability that the verifier reject is</p><script type="math/tex; mode=display">\begin{aligned}\Pr(\mathcal{V} \text{ reject}) &\ge 1- \Pr(\mathcal{G}_1(r_1) =h_1(r_1)) - \Pr(\mathcal{G}_1\left(r_1\right)=\sum_{\left(x_2, \ldots, x_v\right) \in\{0,1\}^{v-1}} \mathcal{G}\left(r_1, x_2, \ldots, x_v\right) \mid \mathcal{G}_1(r_1)=h_1(r_1)) \\&\ge 1-\ell/|\mathbb{F}|-\ell \cdot (\mu-1) /|\mathbb{F}| \\&=1-\ell \cdot \mu /|\mathbb{F}|\end{aligned}</script><!-- Then we define two events:$$\begin{aligned}&E_i:=\text{event that } \mathcal{G}^\star_i(r_i) =\mathcal{G}_i(r_i) \\&W:=\text{event that Verifier accepts}\end{aligned}$$ -->]]></content>
      
      
      
        <tags>
            
            <tag> Zero Knowledge Proof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>$&#92;Theta, O, o, &#92;Omega, &#92;omega$ in Complexity</title>
      <link href="/2024/09/05/Theta-O-o-Omega-omega-in-Complexity/"/>
      <url>/2024/09/05/Theta-O-o-Omega-omega-in-Complexity/</url>
      
        <content type="html"><![CDATA[<h2 id="Theta-渐近紧确界记号，既是上界也是下界，等于的意思-tight"><a href="#Theta-渐近紧确界记号，既是上界也是下界，等于的意思-tight" class="headerlink" title="$\Theta$ - 渐近紧确界记号，既是上界也是下界，等于的意思(tight)"></a>$\Theta$ - 渐近紧确界记号，既是上界也是下界，等于的意思(tight)</h2><p><strong>Definition 1.1</strong>: 设 $f(n)$ 和 $g(n)$ 是定义域为自然数集合的函数。如果 $\lim _{n \rightarrow \infty} \frac{f(n)}{g(n)}$ 存在, 并且等于某个常数 $c(c&gt;0)$, 那么 $f(n)=$ $\Theta(g(n))$ 。通俗理解为 $f(n)$ 和 $g(n)$ 同阶, $\Theta$ 用来表示算法的精确阶。<br><strong>Definition 1.2</strong>: 存在常数 $c_1 、 c_2$ 和 $n_0$, 使得对所有 $n \geq n_0$, 有 $0 \leq c_1 g(n) \leq f(n) \leq c_2 g(n)$, 即若存在常数 $c_1 、 c_2$, 使得对于足够大的 n , 函数 $f(n)$ 能 “夹入” $c_1 g(n)$ 与 $c_2 g(n)$ 之间, 则 $f(n)$ 属于集合 $\Theta(g(n))$, 记作 $f(n) \in \Theta(g(n))$。作为代替, 我们通常记 “ $f(n)=\Theta(g(n))$ “。</p><h2 id="O-渐近上界记号，表示上界，小于等于的意思-tightness-unknown"><a href="#O-渐近上界记号，表示上界，小于等于的意思-tightness-unknown" class="headerlink" title="$O$ - 渐近上界记号，表示上界，小于等于的意思(tightness unknown)"></a>$O$ - 渐近上界记号，表示上界，小于等于的意思(tightness unknown)</h2><p><strong>Definition 2</strong>: 设 $f(n)$ 和 $g(n)$ 是定义域为自然数集 $N$ 上的函数。若存在正数 $c$ 和 $n_0$, 使得对一切 $n \geq n_0$ 都有 $0 \leq f(n) \leq c g(n)$ 成立,则称 $f(n)$ 的渐进的上界是 $g(n)$, 记作 $f(n)=O(g(n))$ 。通俗的说n满足一定条件范围内, 函数 $f(n)$ 的阶不高于函数 $g(n)$ 。</p><h2 id="o-非渐近紧确上界，表示上界，小于的意思-not-tight"><a href="#o-非渐近紧确上界，表示上界，小于的意思-not-tight" class="headerlink" title="$o$ - 非渐近紧确上界，表示上界，小于的意思(not tight)"></a>$o$ - 非渐近紧确上界，表示上界，小于的意思(not tight)</h2><p><strong>Definition 3.1</strong>: 设 $f(n)$ 和 $g(n)$ 是定义域为自然数集 $N$ 上的函数。若对于任意正数 $c$ ，都存在 $n_0$, 使得对一切 $n \geq n_0$ 都有 $0 \leq$ $f(n)&lt;c g(n)$ 成立, 则称 $f(n)$ 的渐进的非紧确上界是 $g(n)$, 记作 $f(n)=o(g(n))$ 。通俗的说 $n$ 满足一定条件范围内, 函数 $f(n)$ 的阶低于函数 $g(n)$ 。<br><strong>Definition 3.2</strong>: 设 $f(n)$ 和 $g(n)$ 是定义域为自然数集合的函数。如果 $\lim _{n \rightarrow \infty} \frac{f(n)}{g(n)}=0$, 那么 $f(n)=o(g(n))$ 。通俗理解为 $f(n)$ 低于 $g(n)$ 的阶。</p><h2 id="Omega-渐进下界记号，表示下界，大于等于的意思-tightness-unknown"><a href="#Omega-渐进下界记号，表示下界，大于等于的意思-tightness-unknown" class="headerlink" title="$\Omega$ - 渐进下界记号，表示下界，大于等于的意思(tightness unknown)"></a>$\Omega$ - 渐进下界记号，表示下界，大于等于的意思(tightness unknown)</h2><p><strong>Definition 4</strong>: 设 $f(n)$ 和 $g(n)$ 是定义域为自然数集 $N$ 上的函数。若存在正数 $c$ 和 $n_0$, 使得对一切 $n \geq n_0$ 都有 $0 \leq c g(n) \leq f(n)$ 成立,则称 $f(n)$ 的渐进的下界是 $g(n)$, 记作 $f(n)=\Omega(g(n))$ 。通俗的说 $n$ 满足一定条件范围内, 函数 $f(n)$ 的阶不低于函数 $g(n)$ 。</p><h2 id="omega-非渐近紧确下界，表示下界，大于的意思-not-tight"><a href="#omega-非渐近紧确下界，表示下界，大于的意思-not-tight" class="headerlink" title="$\omega$ - 非渐近紧确下界，表示下界，大于的意思(not tight)"></a>$\omega$ - 非渐近紧确下界，表示下界，大于的意思(not tight)</h2><p><strong>Definition 5.1</strong>: 设 $f(n)$ 和 $g(n)$ 是定义域为自然数集 $N$ 上的函数。若对于任意正数 $c$, 都存在 $n_0$, 使得对一切 $n \geq n_0$ 都有 $0 \leq$ $c g(n)&lt;f(n)$ 成立, 则称 $f(n)$ 的渐进的非紧确下界是 $g(n)$, 记作 $f(n)=\omega(g(n))$ 。通俗的说 $n$ 满足一定条件范围内, 函数 $f(n)$ 的阶高于函数 $g(n)$ 。<br><strong>Definition 5.2</strong>: 设 $f(n)$ 和 $g(n)$ 是定义域为自然数集合的函数。如果 $\lim _{n \rightarrow \infty} \frac{f(n)}{g(n)}=\infty$ ，那么 $f(n)=o(g(n))$ 。通俗理解为 $f(n)$ 高于 $g(n)$ 的阶。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="table-container"><table><thead><tr><th>记号</th><th>含义</th><th>通俗理解</th></tr></thead><tbody><tr><td>$\Theta$（西塔）</td><td>紧确界。</td><td>相当于”=”</td></tr><tr><td>$O$ （大欧）</td><td>上界。</td><td>相当于”&lt;=”</td></tr><tr><td>$o$（小欧）</td><td>非紧的上界。</td><td>相当于”&lt;”</td></tr><tr><td>$\Omega$（大欧米伽）</td><td>下界。</td><td>相当于”&gt;=”</td></tr><tr><td>$\omega$（小欧米伽）</td><td>非紧的下界。</td><td>相当于”&gt;”</td></tr></tbody></table></div>]]></content>
      
      
      
        <tags>
            
            <tag> Complexity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Combinatorial number system</title>
      <link href="/2024/08/30/Combinatorial-number-system/"/>
      <url>/2024/08/30/Combinatorial-number-system/</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Combinatorial number system represents a non-negative natural numbers as sum of binomial coefficients, which is a correspondence between natural numbers (taken to include 0) N and k-combinations.</p><p>By restricting the number of binomial coefficients, say to r, any non-negative integer m can be represented uniquely as sum of r binomial coefficients. A different value of r would result in a different combinatorial number system.</p><p><strong>Definition</strong>(Combinadics). $\forall m \geq 0, m \in \mathbb{N}_{\geq 0}$, there exist unique $r, C_r, \cdots, C_i, \cdots, C_1$ such that $C_i \geq 0$, and $C_j&gt;C_i$ for $j&gt;i$ and</p><script type="math/tex; mode=display">\begin{aligned}m & =\sum_{i=1}^r\binom{C_i}{i} \\& =\binom{C_r}{r}+\binom{C_{r-1}}{r-1}+\cdots+\binom{C_i}{i}+\cdots+\binom{C_2}{2}+\binom{C_1}{1}\end{aligned}</script><p><strong>Lemma</strong>. Using <a href="https://en.wikipedia.org/wiki/Pascal%27s_triangle">Pascal’s triangle</a>, we can get </p><script type="math/tex; mode=display">\binom{n+1}{r}=\sum_{j=0}^r\binom{n-r+j}{j}=\sum_{j=0}^r\binom{n-j}{r-j}</script><p><strong>Proof</strong>. We prove it using the basic property of the Pascal’s triangle. That is every entry is the sum of two entries in the preceding row, one on the top and the other on the top-left of the current entry.</p><script type="math/tex; mode=display">\begin{aligned}\binom{n+1}{r}= & \binom{n}{r}+\binom{n}{r-1} \\ = & \binom{n}{r}+\binom{n-1}{r-1}+\binom{n-1}{r-2} \\ = & \binom{n}{r}+\binom{n-1}{r-1}+\binom{n-2}{r-2}+\binom{n-2}{r-3} \\ & \vdots \\ = & \binom{n}{r}+\binom{n-1}{r-1}+\cdots+\binom{n-r+i}{i}+\cdots+\binom{n-r+1}{1}+\binom{n-r}{0}\end{aligned}</script><p>as $\binom{n-r}{0}=1$, we have</p><script type="math/tex; mode=display">\binom{n+1}{r}=\sum_{j=1}^r\binom{n-j}{r-j}+1 > \sum_{j=1}^r\binom{n-j}{r-j}</script><p>Then we can prove the bijection between the natural numbers and the k-combinations.<br><strong>Exsitence</strong>. We prove it using mathematical induction.</p><ul><li>Base case: $m=0$, we have <script type="math/tex; mode=display">0=\binom{r-1}{r} + \cdots + \binom{1}{2} + \binom{0}{1}</script></li><li>Inductive hypothesis: Assume that the statement is true for $m$, we have<script type="math/tex; mode=display">m = \binom{C_r}{r} + \cdots + \binom{C_2}{2} + \binom{C_1}{1}</script></li><li>Inductive step:  Add 1 to both sides of above equation, we have<script type="math/tex; mode=display">m + 1 = \binom{C_r}{r} + \cdots + \binom{C_2}{2} + \binom{C_1}{1} + 1</script>Assume the first $j C_i$ ‘s that are consective. That means $C_{l+1}=C_l+1$ for $1 \leq l&lt;j$, we have <script type="math/tex; mode=display">\binom{C_1+j-1}{j}+\cdots+\binom{C_1+1}{2}+\binom{C_1}{1}+1 = \binom{C_1+j}{j}</script>Then we have<script type="math/tex; mode=display">m + 1 = \binom{C_r}{r} + \cdots + \binom{C_1+j+\alpha} + \binom{C_1+j}{j} + \binom{j-2}{j-1} + \cdots + \binom{1}{2} + \binom{0}{1}</script>where $\alpha \ge 1$ means that it’s not consective with the first $j C_i$ ‘s.<br>So we have proved the existence of the bijection between the natural numbers and the k-combinations.</li></ul><p><strong>Uniqueness</strong>. We prove it by contradiction. Assume that there are two different representations of $m$ as sum of binomial coefficients, say</p><script type="math/tex; mode=display">\begin{aligned} & \sum A=\binom{a_r}{r}+\cdots+\binom{a_2}{1}+\binom{a_1}{1} \\ & \sum B=\binom{b_r}{r}+\cdots+\binom{b_2}{1}+\binom{b_1}{1}\end{aligned}</script><p>Consider sets $A^{\prime}=A-B$ and $B^{\prime}=B-A$, carrying elements of $A$ and $B$ that are not present in the other set.<br>Since $A$ and $B$ have equal sums:</p><script type="math/tex; mode=display">\sum A^{\prime} = \sum B^{\prime}</script><p>As $A$ is not equal to $B$, we have $A^{\prime} \neq \emptyset$ and $B^{\prime} \neq \emptyset$.<br>Suppose $\binom{C_A}{r}$ and $\binom{C_B}{r}$ be the largest coefficients in $A^{\prime}$ and $B^{\prime}$ respectively.<br>Since $A^{\prime}$ and $B^{\prime}$ have no common elements, we have $C_A \neq C_B$.<br>Without loss of generality, assume $C_A &gt; C_B$, then we have $C_B + 1 \leq C_A$</p><script type="math/tex; mode=display">\sum B^\prime < \binom{C_B+1}{r}</script><p>So we have</p><script type="math/tex; mode=display">\sum B^\prime < \binom{C_B+1}{r} \leq \binom{C_A}{r} \leq \sum A^\prime</script><p>As $\sum A^\prime = \sum B^\prime$, we have a contradiction. So we have proved the uniqueness of the bijection between the natural numbers and the k-combinations.</p><p><strong>Conclusion</strong>. We have proved the bijection between the natural numbers and the k-combinations.</p><h2 id="Applications"><a href="#Applications" class="headerlink" title="Applications"></a>Applications</h2><p>In the CFS signature scheme[3], the combinatorial number system is used to compress the signature. The original signature is a word of length $n=2^{16}$ bits with weight $w=9$.<br>Since its low hamming weight, we obviouly have an intuition that we can compress it.<br>We totally have $\binom{2^{16}}{9} \approx 2^{125.5}$ kinds of words, so we can use 126 bits to index the word $z$ instead of storing the whole $z$.<br>As we proved above, we have $\binom{2^{16}}{9} = \sum_{i=0}^9\binom{2^{16}-1-i}{9-i}$, so we can use the position of the 1’s in $z$ to index $z$.<br>Let $i_1&lt;\ldots&lt;i_9$ denote the positions of the non-zero bits of $z$. We define the index $I_z$ of $z$ by:</p><script type="math/tex; mode=display">I_z=1+\binom{i_1}{1}+\binom{i_2}{2}+\ldots+\binom{i_9}{9}</script><p>The full CFS signature scheme is as follows:</p><h3 id="Signature-algorithm"><a href="#Signature-algorithm" class="headerlink" title="Signature algorithm"></a>Signature algorithm</h3><ul><li>hash the document $D$ into $s=h(D)$</li><li>compute $s_i=h([\cdots s \cdots \mid \cdot i \cdot])$ for $i=0,1,2 \ldots$</li><li>find $i_0$ the smallest value of $i$ such that $s_i$ is decodable</li><li>use our trapdoor function to compute $z$ such that $H z^T=s_{i_0}$</li><li>compute the index $I_z$ of $z$ in the space of words of weight 9</li><li>use $\left[\cdots I_z \cdots \mid \cdot i_0 \cdot\right]$ as a signature for D</li></ul><h3 id="Verification-algorithm"><a href="#Verification-algorithm" class="headerlink" title="Verification algorithm"></a>Verification algorithm</h3><ul><li>recover $z$ from its index $I_z$</li><li>compute $s_1=H z^T$ with the public key $H$</li><li>compute $s_2=h\left(\left[\cdots h(D) \cdots \mid \cdot i_0 \cdot\right]\right)$ with the public hash function</li><li>compare $s_1$ and $s_2$ : if they are equal the signature is valid</li></ul><h2 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h2><p>As we can see, there is a bijection between the index $I_z$ and the word $z$, so intuitively it’s a theoretical upper bound.<br>The easiest way to compress the signature is to use the 9 positions of the 1’s in $z$ to index $z$. Every position is $\log{2^{16}}=16$ bits, so we need $9 \times 16=144$ bits to index $z$.<br>We can think about why there are redundant $144-126=18$ bits here, and where does the redundancy come from?<br>I think the redundancy here comes from the possibility that the position of 1 in the back is smaller than the position of 1 in the front, but it does not exist in reality.<br>This is one of the redundancy situations, maybe there are other situations that we won’t discuss here.</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] <a href="http://math0.wvstateu.edu/~baker/cs405/code/Combinadics.html">http://math0.wvstateu.edu/~baker/cs405/code/Combinadics.html</a><br>[2] Siddique A B, Farid S, Tahir M. Proof of bijection for combinatorial number system[J]. arXiv preprint arXiv:1601.05794, 2016.<br>[3] Courtois N T, Finiasz M, Sendrier N. How to achieve a McEliece-based digital signature scheme[C]//Advances in Cryptology—ASIACRYPT 2001: 7th International Conference on the Theory and Application of Cryptology and Information Security Gold Coast, Australia, December 9–13, 2001 Proceedings 7. Springer Berlin Heidelberg, 2001: 157-174.<br>[4] Bernstein D J, Buchmann J, Dahmen E. Post-Quantum Cryptography. Mathematics and Statistics Springer-11649[R]. ZDB-2-SMA. Springer, Heidelberg, 2009.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Mathematics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Code-based cryptography II - Niederreiter system and schoolbook attaccks</title>
      <link href="/2024/08/28/Code-based-cryptography-II-Niederreiter-system-and-schoolbook-attaccks/"/>
      <url>/2024/08/28/Code-based-cryptography-II-Niederreiter-system-and-schoolbook-attaccks/</url>
      
        <content type="html"><![CDATA[<h2 id="Systematic-form"><a href="#Systematic-form" class="headerlink" title="Systematic form"></a>Systematic form</h2><p><strong>系统生成矩阵 $G$</strong> 是形式为 $[I_k | P]$ 的矩阵，其中 $I_k$ 是 $k \times k$ 的单位矩阵，$P$ 是 $k \times (n-k)$ 的矩阵（冗余部分）。系统阵生成的码字前 $k$ 位是信息位，后 $n-k$ 位是校验位。<br><strong>系统校验矩阵 $H$</strong> 是形式为$[P^T | I_{n-k}]$的矩阵，即 $H$ 是 $n \times n-k$ 的矩阵，$P^T$ 是 $n-k \times k$ 的生成矩阵的$P$的转置，$I_{n-k}$ 是 $n-k \times n-k$ 的单位矩阵。</p><script type="math/tex; mode=display">H(\mathbf{m} G)^{T}=H G^{T} \mathbf{m}^{T}=\left(P^{T} \mid I_{n-k}\right)\left(I_k \mid P\right)^{T} \mathbf{m}^{T}=0 .</script><p>在存储和传输的时候我们可以只存储和传输 $P$，以节省空间。</p><h3 id="Different-views-on-decoding"><a href="#Different-views-on-decoding" class="headerlink" title="Different views on decoding"></a>Different views on decoding</h3>]]></content>
      
      
      
        <tags>
            
            <tag> Cryptography </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Code-based cryptography I - Basic concepts and McElice system</title>
      <link href="/2024/08/23/Code-based-cryptography-I-Basic-concepts-and-McElice-system/"/>
      <url>/2024/08/23/Code-based-cryptography-I-Basic-concepts-and-McElice-system/</url>
      
        <content type="html"><![CDATA[<h2 id="Error-correction-code"><a href="#Error-correction-code" class="headerlink" title="Error correction code"></a>Error correction code</h2><p>在计算机，电信，信息理论和编码理论中，纠错码（ECC，error correction/correcting code）是信息传输中错误检测与纠正的工具。许多系统都会检查数据在传输过程中是否损坏，比如ISBN码的最后一位。<br>一般来说，通常会讲 $k$ 比特的数据存储为 $n$ 比特，增加 $n-k$ 比特的冗余信息，以便在传输过程中检测和纠正错误。如果没有发生错误，这 $n$ 比特会满足 $n-k$ 个检验方程；否则可以从错误模式中纠正错误。<br>一个好的纠错码会在引入尽可能少的冗余信息的情况下，纠正尽可能多的错误。<br>纠错 $t$ 个错误的纠错码并不意味不能纠错 $t+1$ 个错误。</p><p>纠错码分为两大类：分组码和卷积码。</p><ul><li>分组码适用于一连串固定长度的数据包，而每一种分组码只能用于特定长度的数据包。实际用途中的分组码一般使用硬解码方式，所需时间为每一个数据包长度的多项式时间。</li><li>卷积码适用于任意长度的比特流/符号流。接收方通常使用维特比算法将其软解码，但有时也会用其他算法。随着卷积码约束条件的长度增加，维特比解码的解码效率渐近最优；但作为代价，计算时间将以对数式增长。<br><img src="/imgs/cbe/coding_scheme.png" alt="error correction code"></li></ul><h3 id="Linear-code"><a href="#Linear-code" class="headerlink" title="Linear code"></a>Linear code</h3><p>长度为 $n$，维度为 $k$ 的线性码 $C$ 是 $\mathbb{F}_p$ 的 $k$ 维子空间。这样的代码称为q元(q-ary)码。C中的向量称为码字。码的大小是码字的数量，等于$q^k$。<br>线性码$C$有两种理解方式：</p><ul><li>生成矩阵(Geneartor matrix) $G, G\in \mathbb{F}_p^{k*n}$ 的 $k$ 个行向量张成的空间，$C = \{mG | m \in \mathbb{F}_p^k\}$。</li><li>校验矩阵(Parity-check matrix) $H$, $C$为由$H$表示的线性变换 $\phi: \mathbb{F}_q^n \rightarrow \mathbb{F}_q^{n-k} $ 的核(kernel space)，$C = \{c \in \mathbb{F}_q^n | cH^T = 0\}$。$H$生成的码称为$C$的对偶码。</li></ul><p>线性码的任何线性组合仍然属于该码，因此有线性码的最小距离是最小非零码的汉明重量。</p><script type="math/tex; mode=display">\min _{c,c_0 \in C, c \neq c_0} d\left(c, c_0\right)=\min _{c,c_0 \in C, c \neq c_0} d\left(c-c_0, 0\right)=\min _{c \in C, c \neq 0} d(c, 0)=d</script><h3 id="Decoding-problem"><a href="#Decoding-problem" class="headerlink" title="Decoding problem"></a>Decoding problem</h3><p>解码问题(Decoding problem)是指给定$x\in \mathbb{F}_p^n$，找到最接近$x$的码字$c\in C$。令$x=c+e$，$e$是错误向量，注意找到最接近$x$的码字等价于找到最小的汉明重量的错误向量$e$。</p><ul><li>如果 $x$ 中存在 $t$ 个错误，即错误向量 $e$ 的汉明重量是 $t$，这被称为 $t-$错误校正问题（t-error correcting problem）。</li><li>存在许多具有快速解码算法的编码族，例如里德-所罗门码（Reed-Solomon codes）、戈帕码/交替码（Goppa codes/alternant codes）等。</li><li><strong>通常的解码问题是困难的：最好的方法-信息集解码（Information-set decoding）需要指数级时间</strong>。</li></ul><h2 id="The-McEliece-cryptosystem"><a href="#The-McEliece-cryptosystem" class="headerlink" title="The McEliece cryptosystem"></a>The McEliece cryptosystem</h2><p>参考Robert McEliece 1978[2]，McEliece密码系统是一种基于编码的公钥密码系统，它的安全性基于解码问题的困难性。<br>设 $C$ 为长度为 $n$ 的二元 Goppa 码 $\Gamma$，其维数为 $k$，最小距离为 $2t+1$，其中 $t \approx (n-k) / \log_2(n)$；原始参数（1978年）为 $n=1024, k=524, t=50$：</p><ul><li>McEliece 密钥包含 $\Gamma$ 的生成矩阵 $G$，一个高效的 $\Gamma$ $t$ 错误校正解码算法；一个 $n \times n$ 的置换矩阵 $P$ 和一个非奇异的 $k \times k$ 矩阵 $S$。</li><li>$n, k, t$ 是公开的；但是 $\Gamma, P, S$ 是随机生成的秘密。</li><li>McEliece 公钥是 $k \times n$ 矩阵 $G^{\prime} = S G P$。</li></ul><h3 id="Encryption"><a href="#Encryption" class="headerlink" title="Encryption"></a>Encryption</h3><ul><li>选择一个 $k$ 比特信息向量 $m$，将其编码为 $c = mG^{\prime}$；</li><li>产生一个 $n$ 比特，重量为 $t$ 的随机向量 $e$，计算 $y = c + e$；</li><li>发送 $y$。</li></ul><h3 id="Decryption"><a href="#Decryption" class="headerlink" title="Decryption"></a>Decryption</h3><ul><li>接收到 $y$ 后，计算 $yP^{-1} = mG + eP^{-1}$；</li><li>由于 $P$ 是置换矩阵，$eP^{-1}$ 仍然是一个重量为 $t$ 的向量；</li><li>使用 $\Gamma$ 的 $t$ 错误校正解码算法，找到$mS$ 和 $m$。</li></ul><h3 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h3><p>攻击者面临的挑战是将  $y$  解码到由  $G{\prime}$  生成的码中最近的码字  $mG{\prime}$ 。如果  $G{\prime}$  不暴露任何特殊结构，这就是一般解码问题。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] <a href="https://www.youtube.com/watch?v=9EC2taInna4&amp;list=PL6hzlGxGIS1DcTZq6Fv1yq0_dmqDaNN4v">https://www.youtube.com/watch?v=9EC2taInna4&amp;list=PL6hzlGxGIS1DcTZq6Fv1yq0_dmqDaNN4v</a><br>[2] McEliece R J. A public-key cryptosystem based on algebraic[J]. Coding Thv, 1978, 4244: 114-116.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Cryptography </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Explanation of &#39;IND-&#39; Security Notions</title>
      <link href="/2024/08/21/Explanation-of-IND-Security-Notions/"/>
      <url>/2024/08/21/Explanation-of-IND-Security-Notions/</url>
      
        <content type="html"><![CDATA[<p>There are many schemes that advertise themselves as IND-secure, but what does that mean? In this post, we will explain the IND-CPA, IND-CCA1 and IND-CCA2 security notions. We will also discuss the differences between them and when to use each one.</p><h2 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h2><p>Before we dive into security notions, let’s first define some terms that we will use throughout this post.</p><p>Without loss of generality, we will assume that an encryption scheme consists of three algorithms: a key generation algorithm $\operatorname{Key-Gen}$, an encryption algorithm $\operatorname{Enc}$, and a decryption algorithm $\operatorname{Dec}$. </p><p>The ideal functionality of an encryption scheme is to ensure that an adversary cannot learn anything about the plaintext message from the ciphertext, which means that for every ciphertext $C=\operatorname{Enc}(K,M)$, if the key remains secret for the adversary, the probability of identifying $M$ is impossible. </p><p>Since that is not possible in practice, a reasonable approach is to define constraints strong enough to satisfy some definition of security. The “<strong>IND-</strong>“ notation provides such definitions in terms of games, where a challenger keeps his key secret, and an adversary has certain capabilities and his target is to break the encryption system.</p><h2 id="IND-CPA-INDistinguishability-under-Chosen-Plaintext-Attack"><a href="#IND-CPA-INDistinguishability-under-Chosen-Plaintext-Attack" class="headerlink" title="IND-CPA: INDistinguishability under Chosen Plaintext Attack"></a>IND-CPA: INDistinguishability under Chosen Plaintext Attack</h2><p>In words: the adversary generates two messages of equal length. The challenger decides, randomly, to encrypt one of them. The adversary tries to guess which of the messages was encrypted with access to a encryption oracle.</p><p>Algorithm: </p><ol><li>Challenger: $(pk,sk) \leftarrow \operatorname{Key-Gen}(1^n)$</li><li>Adversary: choose two messages $M_0,M_1$ of equal length from message space $\mathcal{M}$. Send $M_0,M_1$ to the challenger. Perform additional operations in polynomial time including calls to the encryption oracle.</li><li>Challenger: choose $b \leftarrow \{0,1\}$ and send $C^* \leftarrow \operatorname{Enc}(pk,M_b)$ to the adversary.</li><li>Adversary: Perform additional operations in polynomial time including calls to the encryption oracle and output a guess $b’$ for $b$.</li><li>Adversary wins if $b=b’$.</li></ol><p>Further comment: the adversary is said to have won the game if he can guess the bit $b$ with a probability non-negligible higher than $1/2$. The encryption scheme is said to be IND-CPA secure if no <strong>polynomial-time</strong> adversary can win the game with a probability non-negligible higher than $1/2$.</p><h2 id="IND-CCA1-INDistinguishability-under-Chosen-Ciphertext-Attack"><a href="#IND-CCA1-INDistinguishability-under-Chosen-Ciphertext-Attack" class="headerlink" title="IND-CCA1: INDistinguishability under Chosen Ciphertext Attack"></a>IND-CCA1: INDistinguishability under Chosen Ciphertext Attack</h2><p>In words: the adversary can query a encryption and decryption oracle before accepting the ciphertext. The adversary tries to guess which of the messages was encrypted.</p><p>Algorithm:</p><ol><li>Challenger: $(pk,sk) \leftarrow \operatorname{Key-Gen}(1^n)$</li><li>Adversary: Perform additional operations in polynomial time including calls to the encryption and decryption oracles. choose two messages $M_0,M_1$ of equal length from message space $\mathcal{M}$. Send $M_0,M_1$ to the challenger.</li><li>Challenger: choose $b \leftarrow \{0,1\}$ and send $C^* \leftarrow \operatorname{Enc}(pk,M_b)$ to the adversary.</li><li>Adversary: Output a guess $b’$ for $b$.</li><li>Adversary wins if $b=b’$.</li></ol><p>Further comment: IND-CCA1 considers the possibility of repeated interaction, implying that security does not weaken with time.</p><h2 id="IND-CCA2-INDistinguishability-under-Adaptive-Chosen-Ciphertext-Attack"><a href="#IND-CCA2-INDistinguishability-under-Adaptive-Chosen-Ciphertext-Attack" class="headerlink" title="IND-CCA2: INDistinguishability under Adaptive Chosen Ciphertext Attack"></a>IND-CCA2: INDistinguishability under Adaptive Chosen Ciphertext Attack</h2><p>In words:  In addition to its capabilities under IND-CCA1, the adversary is now given access to the oracles after receiving ciphertext, but cannot send ciphertext to the decryption oracle.</p><p>Algorithm:</p><ol><li>Challenger: $(pk,sk) \leftarrow \operatorname{Key-Gen}(1^n)$</li><li>Adversary: perform additional operations in polynomial time including calls to the encryption and decryption oracles. choose two messages $M_0,M_1$ of equal length from message space $\mathcal{M}$. Send $M_0,M_1$ to the challenger.</li><li>Challenger: choose $b \leftarrow \{0,1\}$ and send $C^* \leftarrow \operatorname{Enc}(pk,M_b)$ to the adversary.</li><li>Adversary: Perform additional operations in polynomial time including calls to the encryption and decryption oracles, and output a guess $b’$ for $b$.</li><li>Adversary wins if $b=b’$.</li></ol><p>Further comment: IND-CCA2 suggests that using the decryption oracle after knowing the ciphertext can give a reasonable advantage in some schemes, since the requests to the oracle could be customized depending on the specific ciphertext.</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ol><li>IND-CCA1 does not imply non-malleability (at least for the asymmetric case, Bellare et al. proved that IND-CCA1 does not imply NM-CPA)</li><li>Two messages might not be selected randomly by the adversary.</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Cryptography </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Primitive Polynomial &amp; Cyclotomic Coset</title>
      <link href="/2024/08/17/Primitive-Polynomial&amp;Cyclotomic-Coset/"/>
      <url>/2024/08/17/Primitive-Polynomial&amp;Cyclotomic-Coset/</url>
      
        <content type="html"><![CDATA[<p>前置知识：有限域、不可约多项式、<a href="/2024/08/12/Cyclotomic-polynomial/">分圆多项式</a></p><p>最近在学习LDPC、MDPC码的时候，涉及到了很多多项式的知识，对有限域上的多项式又加深了一些理解，所以在这里记录一下，可能会比较乱，相当于是一个随笔。</p><h2 id="Primitive-Polynomial"><a href="#Primitive-Polynomial" class="headerlink" title="Primitive Polynomial"></a>Primitive Polynomial</h2><p>我们首先看wiki百科对于<a href="https://en.wikipedia.org/wiki/Primitive_polynomial">本原多项式</a>的定义：</p><p>In different branches of mathematics, primitive polynomial may refer to:</p><ul><li><a href="https://en.wikipedia.org/wiki/Primitive_polynomial_(field_theory)">Primitive polynomial (field theory)</a>, a minimal polynomial of an extension of finite fields</li><li><a href="https://en.wikipedia.org/wiki/Primitive_polynomial_(ring_theory)">Primitive polynomial (ring theory)</a>, a polynomial with coprime coefficients</li></ul><p>在本篇博客中，我们主要关注于有限域上的本原多项式，因为有限域上的本原多项式有很多有趣的性质：</p><ul><li>首先从定义中可知，有限域上的本原多项式一定是不可约多项式（irreducible）。<br><strong>Proof：</strong>根据定义可知，本原多项式是满足本原根的最小多项式。</li><li>有限域 $\operatorname{GF}(p)$ 上的 $m$ 次不可约多项式 $F(x)$（其中 $p$ 是质数），如果满足 $F(x)$ 整除 $x^n - 1$ 最小$n$ 等于 $p^m - 1$，则多项式 $F(x)$为本原多项式。<br><strong>Proof：</strong>最小$n$ 等于 $p^m - 1$意味着 $F(x)$ 存在一个根仅在${p^m-1}$次的时候才等于1，即为本原单位根。</li><li>$m$次的本原多项式在$\operatorname{GF}(p^m)$有$m$个不同的（共轭）根，均是本原单位根，且这些根构成了一个分圆陪集（cyclic coset）。<br><strong>Proof：</strong>考虑$s$与$p^m-1$互素，那么$sp^k$必与$p^m-1$互素，而且分圆陪集中的元素恰有$m$个$\{s,sp,sp^2,\dots,sp^{m-1}\}$。 <a id="appendix"></a></li><li>在$\operatorname{GF}(p)$上，恰好有$\varphi\left(p^m-1\right)$本原元和$\varphi\left(p^m-1\right)/m$本原多项式，次数均为$m$。<br><strong>Proof：</strong><a href="#appendix">见上一条证明</a></li></ul><p>如何理解本原多项式引导出的扩域呢？我们可以类比$\mathbb{R}$到$\mathbb{C}$的代数扩展：取$f (x) = x^2 + 1 \in \mathbb{R}(x)$，并将虚数定义为$f (i) = 0$。之后我们可以在$\mathbb{R}$中附加$i$，从而得到一个$\mathbb{R}$上的二维空间$\mathbb{C}$。<br>我们现在回过头来看$\mathbb{F}_{2^4}=\mathbb{F}_{16}$，选取本原多项式$f(\alpha)=\alpha^4 + \alpha + 1$，我们有$\alpha^4 = \alpha + 1$，从而在$\mathbb{F}_2$中附加$\alpha$，由于$1,\alpha,\alpha^2,\alpha^3$互相之间不存在线性关系，因此我们可以得到一个$\mathbb{F}_2$上的四维空间$\mathbb{F}_{16}$，任何高于四次的多项式都可以通过$\alpha^4 = \alpha + 1$进行简化。（任何高于四维的元素都是线性相关的）</p><h2 id="Cyclotomic-Coset"><a href="#Cyclotomic-Coset" class="headerlink" title="Cyclotomic Coset"></a>Cyclotomic Coset</h2><p>接下来我们给出一些更有趣的概念：<br><strong>Lemma：</strong>$(x+y)^{p^m} = x^{p^m} + y^{p^m} \mod p$</p><p><strong>Proof：</strong></p><script type="math/tex; mode=display">\begin{aligned}& (x+y)^p=x^p+\ldots+\binom{p}{i} x^{p-i} y^i+\ldots+y^p \\& \binom{p}{i}=\frac{p(p-1) \ldots(p-i+1)}{i(i-1) \ldots} \equiv 0 \bmod p \quad \text { for } i \neq 0, n \\&(x+y)^{p^m} \equiv\left[(x+y)^{p^{m-1}}\right]^p \equiv\left[(x)^{p^{m-1}}+(y)^{p^{m-1}}\right]^p \equiv x^{p^m}+y^{p^m} \bmod p\end{aligned}</script><p><strong>Theorem：</strong> 如果$\beta \in \mathbb{F}_{p^m}$，那么 $\beta$ 和 $\beta^p$有相同的最小多项式。<br><strong>Proof：</strong> $f\left(\beta^p\right)=\sum f_i \beta^{p i}=\left(\sum f_i \beta^i\right)^p=(f(\beta))^p=0$</p><p>我们进一步来看一些有趣的性质：我们令本原多项式为$f(\alpha)=\alpha^4 + \alpha + 1$，可以看到$\alpha, \alpha^2, \alpha^4, \alpha^8$有相同的最小多项式，并且该多项式恰有四个根。</p><script type="math/tex; mode=display">\begin{aligned}m(x)&=(x-\alpha)\left(x-\alpha^2\right)\left(x-\alpha^4\right)\left(x-\alpha^8\right)\\&= x^4 - (\alpha^8 + \alpha^4 + \alpha^2 + \alpha)x^3 + (\alpha^{12} + \alpha^{10} + \alpha^{9} + \alpha^6 + \alpha^5 + \alpha^3)x^2 - (\alpha^{14} + \alpha^{13} + \alpha^{11} + \alpha^7)x + \alpha^{15}\end{aligned}</script><p>可以发现每一项的系数$b$都满足$b^2=b$，因此$b$一定位于$\mathbb{F}_2中$。</p><script type="math/tex; mode=display">\begin{aligned}(\alpha^8 + \alpha^4 + \alpha^2 + \alpha)^2 &=  \alpha^{16} + \alpha^8 + \alpha^4 + \alpha^2 =   \alpha + \alpha^8 + \alpha^4 + \alpha^2\\(\alpha^{12} + \alpha^{10} + \alpha^{9} + \alpha^6 + \alpha^5 + \alpha^3)^2 &= \alpha^{24} + \alpha^{20} + \alpha^{18} + \alpha^{12} + \alpha^{10} + \alpha^6 = \alpha^{9} + \alpha^{5} + \alpha^{3} + \alpha^{12} + \alpha^{10} + \alpha^3\\(\alpha^{14} + \alpha^{13} + \alpha^{11} + \alpha^7)^2 &= \alpha^{28} + \alpha^{26} + \alpha^{22} + \alpha^{14} = \alpha^{13} + \alpha^{11} + \alpha^{7} + \alpha^{14}\\\end{aligned}</script><p>其实，很容易证明，任意一个分圆陪集构造出来的系数都位于$\mathbb{F}_2$中。</p><p><strong>Definition：</strong>分圆陪集(Cyclotomic Coset)是一个集合，模$p$的分圆陪集为$\{s,sp,sp^2,\dots,sp^{m-1}\}$。</p><script type="math/tex; mode=display">\begin{aligned}&\text { Example: } \mathrm{p}=2, \mathrm{m}=4\\&\begin{array}{ll}C_0=\{0\} & m_0=x+1 \\C_1=\{1,2,4,8\} & m_1=x^4+x+1=m_2=m_4=m_8 \\C_3=\{3,6,9,12\} & m_3=x^4+x^3+x^2+x+1=m_6=m_9=m_{12} \\C_5=\{5,10\} & m_5=x^2+x+1=m_{10} \\C_7=\{7,11,13,14\} & m_7=x^4+x^3+1=m_{11}=m_{13}=m_{14}\end{array}\end{aligned}</script><p>由上面我们又想到了一个等式：</p><script type="math/tex; mode=display">m_1(x) m_3(x) m_5(x) m_7(x) = x^{16} - 1</script><p>$m_1(x),m_3(x),m_5(x),m_7(x)$并非都是本原多项式，其中只有$m_1(x), m_7(x)$是本原多项式（1和7与15互素）。注意这些多项式与分圆多项式之间的区别：分圆多项式应该是$m_1(x) m_7(x)$。这是不是又是一种快速求分圆多项式的方法呢？（尝试一下还真是，数学真是奇妙啊!）<br><strong>整理一下这个方法：首先我们要找到一个本原多项式，然后利用这个本原根生成不同分圆陪集的最小多项式，利用其中与$p^m-1$互素的多项式相乘，就可以得到分圆多项式。</strong></p><h2 id="仙人指路"><a href="#仙人指路" class="headerlink" title="仙人指路"></a>仙人指路</h2><p>之所以叫仙人指路是因为我是看到了这一个例子才理解了Cyclotomic Coset这个概念，放在这里仅供参考。</p><p>Over GF(3) the polynomial $x^2+1$ is irreducible but not primitive because it divides $x^4-1$ : its roots generate a cyclic group of order 4 , while the multiplicative group of $\operatorname{GF}\left(3^2\right)$ is a cyclic group of order 8 . The polynomial $x^2+2 x+2$, on the other hand, is primitive. Denote one of its roots by $\alpha$. Then, because the natural numbers less than and relatively prime to $3^2-1=8$ are $1,3,5$, and 7 , the four primitive roots in $\mathrm{GF}\left(3^2\right)$ are $\alpha, \alpha^3=2 \alpha+1, \alpha^5=2 \alpha$, and $\alpha^7=\alpha+2$. The primitive roots $\alpha$ and $\alpha^3$ are algebraically conjugate. Indeed $x^2+2 x+2=(x-\alpha)(x-(2 \alpha+1))$. The remaining primitive roots $\alpha^5$ and $\alpha^7=\left(\alpha^5\right)^3$ are also algebraically conjugate and produce the second primitive polynomial: $x^2+x+2=(x-2 \alpha)(x-(\alpha+2))$.</p><p>For degree $3, \operatorname{GF}\left(3^3\right)$ has $\varphi\left(3^3-1\right)=\varphi(26)=12$ primitive elements. As each primitive polynomial of degree 3 has three roots, all necessarily primitive, there are $12 / 3=4$ primitive polynomials of degree 3 . One primitive polynomial is $x^3+2 x+1$. Denoting one of its roots by $\gamma$, the algebraically conjugate elements are $\gamma^3$ and $\gamma^9$. The other primitive polynomials are associated with algebraically conjugate sets built on other primitive elements $\gamma^r$ with $r$ relatively prime to 26 :</p><script type="math/tex; mode=display">\begin{aligned}x^3+2 x+1 & =(x-\gamma)\left(x-\gamma^3\right)\left(x-\gamma^9\right) \\x^3+2 x^2+x+1 & =\left(x-\gamma^5\right)\left(x-\gamma^{5 \cdot 3}\right)\left(x-\gamma^{5 \cdot 9}\right)=\left(x-\gamma^5\right)\left(x-\gamma^{15}\right)\left(x-\gamma^{19}\right) \\x^3+x^2+2 x+1 & =\left(x-\gamma^7\right)\left(x-\gamma^{7 \cdot 3}\right)\left(x-\gamma^{7 \cdot 9}\right)=\left(x-\gamma^7\right)\left(x-\gamma^{21}\right)\left(x-\gamma^{11}\right) \\x^3+2 x^2+1 & =\left(x-\gamma^{17}\right)\left(x-\gamma^{17 \cdot 3}\right)\left(x-\gamma^{17 \cdot 9}\right)=\left(x-\gamma^{17}\right)\left(x-\gamma^{25}\right)\left(x-\gamma^{23}\right)\end{aligned}</script><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] <a href="https://en.wikipedia.org/wiki/Primitive_polynomial">https://en.wikipedia.org/wiki/Primitive_polynomial</a><br>[2] <a href="https://wuli.wiki/online/FldExp.html">https://wuli.wiki/online/FldExp.html</a><br>[3] Ouzan S, Be’ery Y. Moderate-density parity-check codes[J]. arXiv preprint arXiv:0911.3262, 2009.<br>[4] <a href="https://user.eng.umd.edu/~abarg/626/">https://user.eng.umd.edu/~abarg/626/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Mathematics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FFT &amp; NTT</title>
      <link href="/2024/08/13/FFT-NTT/"/>
      <url>/2024/08/13/FFT-NTT/</url>
      
        <content type="html"><![CDATA[<blockquote><p>$e^{i \theta}=\cos (\theta)+i * \sin (\theta)$</p></blockquote><h2 id="FFT-Fast-Fourier-Transformation"><a href="#FFT-Fast-Fourier-Transformation" class="headerlink" title="FFT-Fast Fourier Transformation"></a>FFT-Fast Fourier Transformation</h2><p>快速傅里叶变换（Fast Fourier Transform, FFT），是快速计算序列的离散傅立叶变换（DFT）及其逆变换的方法，将计算复杂度从 $O(n^2)$ 降低到 $O(n\log n)$ ，其中 $n$ 为序列的长度。在密码学场景下，就是为了加速多项式乘法。</p><p>首先，我们考虑多项式:</p><script type="math/tex; mode=display">A(x) = a_n x^n + a_{n-1} x^{n-1} + a_{n-2} x^{n-2} + \cdots + a_1 x + a_0B(x) = b_n x^n + b_{n-1} x^{n-1} + b_{n-2} x^{n-2} + \cdots + b_1 x + b_0</script><p>我们要计算 $C(x) = A(x) \cdot B(x)$ ，即两个多项式的乘积，那么我们可以想到的最简单的方法就是$O(N^2)$：将每一项依次分别相乘再相加。</p><script type="math/tex; mode=display">C(x) = \sum_{i=0}^{2n} c_i x^i = \sum_{i=0}^{2n} \left( \sum_{j=0}^{i} a_j b_{i-j} \right) x^i</script><p>这样的时间复杂度肯定是不可接受的，所以我们需要寻找更快的方法。</p><h3 id="Priliminary"><a href="#Priliminary" class="headerlink" title="Priliminary"></a>Priliminary</h3><h4 id="单位根"><a href="#单位根" class="headerlink" title="单位根"></a>单位根</h4><p>首先，我们需要引入一个复数 $w$ ，满足 $w^n = 1$ ，即 $w$ 是 $n$ 次单位根。考虑欧拉公式$e^{i \theta}=\cos (\theta)+i * \sin (\theta)$，我们可以得到 $w_n^k = e^{2\pi i k / n}, k\in [n]$ ，可以发现，复数的 $n$ 次单位根平分单位圆。<br>单位根还具有一些特殊的性质：</p><ol><li>$w_{dn}^{dk} = \cos (2\pi d k / dn)+i * \sin (2\pi d k / dn) = w_n^k$</li><li>$w_n^{k+n/2} = \cos (2\pi k / n + \pi)+i * \sin (2\pi k / n + \pi) = - \cos (2\pi k / n ) - i  \sin (2\pi k / n + \pi) = -w_n^{k}$</li><li>$w_n^{k+n} = \cos (2\pi k / n + 2\pi)+i * \sin (2\pi k / n + 2\pi) = w_n^{k}$</li><li>$w_n^0 = 1$</li></ol><h4 id="DFT"><a href="#DFT" class="headerlink" title="DFT"></a>DFT</h4><p>已知 $A(x)$ 的系数为 $\left(a_0, a_1, \ldots, a_{n-1}\right)$, 对于 $k=0,1, \ldots, n-1$, 定义:</p><script type="math/tex; mode=display">y_k=A\left(w_n^k\right)=\sum_{i=0}^{n-1} a_i w_n^{k i}</script><p>其中向量 $y=(y_0, y_1, \ldots, y_{n-1})$ 是系数向量 $a=\left(a_0, a_1, \ldots, a_{n-1}\right)$ 的离散傅立叶变换。</p><h4 id="多项式系数表示法"><a href="#多项式系数表示法" class="headerlink" title="多项式系数表示法"></a>多项式系数表示法</h4><p>设 $A(x)$ 表示一个d次多项式, 则 $A(x)=a_0+a_1x+\ldots,+a_d x^d$<br>利用这种方法计算多项式卷积复杂度为 $O\left(d^2\right)$, 其实就是直接对应相乘（暴力）。<br>例如: $A(x)=1+2 x+x^2, B(x)=1-2 x+x^2$</p><script type="math/tex; mode=display">A(x) B(x)=\left(1+2 x+x^2\right)\left(1-2 x+x^2\right)=1-2 x^2+x^4</script><h4 id="多项式点值表示法"><a href="#多项式点值表示法" class="headerlink" title="多项式点值表示法"></a>多项式点值表示法</h4><p>设 $A(x)$ 表示一个d次多项式, 我们知道该多项式在 $d+1$ 个点的值就可以唯一确定这个多项式。<br>因此，我们任取 $d+1$ 个点 $x_0,x_1,\ldots,x_d$，则 $A(x)$ 在这些点的值为 $A(x_0),A(x_1),\ldots,A(x_d)$，我们可以用这些点的值来表示多项式 $A(x)$。</p><script type="math/tex; mode=display">T = ((x_0,A(x_0)),(x_1,A(x_1)),\ldots,(x_d,A(x_d)))</script><p>在点值表示法下，多项式的乘法可以转化为点值的乘法，即 $A(x)B(x)$ 在 $d+1$ 个点的值为 $A(x_i)B(x_i)$ 的乘积，计算复杂度是 $O(d)$。但是要注意一个问题$A(x)B(x)$是一个 $2d$ 次多项式，因此我们需要找到 $2d+1$ 个点来表示这个多项式。</p><p>因此，我们想到了一个方法，将多项式转化为点值表示，进行$O(d)$的乘法，然后再将点值表示的结果转化为多项式。但是这个转化的过程是如何进行的呢？如果我们采用普通求值的方法，复杂度仍然是 $O(d^2)$ 的。接下来，我们就开始逐步进行优化，引入FFT算法。</p><h3 id="FFT-Algorithm"><a href="#FFT-Algorithm" class="headerlink" title="FFT Algorithm"></a>FFT Algorithm</h3><p>我们现在的首要问题是如何将多项式快速转化为点值表示，并且如何将点值表示的结果句快速转化为多项式，这就是<strong>单位根</strong>的作用了。我们观察我们手中的多项式 $F(x)$ ，假设$n=2^k$，我们可以将其分为奇数项和偶数项：</p><script type="math/tex; mode=display">F(x)=a_0+a_1 x+a_2 x^2+\ldots+a_{2n-1} x^{2n-1}=a_0+a_2 x^2+\ldots+a_{n-2} x^{n-2}+x(a_1+a_3 x+\ldots+a_{n-1} x^{n-2})</script><p>将其转化为两个$n/2$次的多项式$FL(x)$和$FR(x)$</p><script type="math/tex; mode=display">FL(x)=a_0+a_2 x+\ldots+a_{n-2} x^{n/2-1}\\FR(x)=a_1+a_3 x+\ldots+a_{n-1} x^{n/2-1}\\F(x)=FL(x^2)+x FR(x^2)</script><p>如果$k&lt; n/2$，把$w_n^k$代入$F(x)$，我们可以得到：$F(w_n^k)=FL(w_{n}^{2k})+w_n^k FR(w_{n}^{2k})$，即$F(w_n^k)=FL(w_{n/2}^{k})+w_n^k FR(w_{n/2}^{k})$；如果$k&gt; n/2$，则有$F(w_n^k)=FL(w_{n/2}^{k-n/2})- w_n^{k-n/2} FR(w_{n/2}^{k-n/2})$。<br>如果我们知道了$FL(x)$和$FR(x)$在$w_{n/2}^{k}$处的值，我们就可以通过上述公式计算出$F(x)$在$w_n^k$处的值。<br>接着我们就可以利用<strong>分治</strong>思想，通过一个递归的算法来计算出$F(x)$ 在 $w_n^0, w_n^1, \ldots, w_n^{n-1}$ 处的点值表示。复杂度为$O(n\log n)$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">FFT</span>(<span class="params">P</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(P)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> P</span><br><span class="line">    w = <span class="number">1</span></span><br><span class="line">    wn = cmath.exp(<span class="number">2</span> * cmath.pi * <span class="number">1j</span> / n)</span><br><span class="line">    P0 = [P[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n, <span class="number">2</span>)]</span><br><span class="line">    P1 = [P[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n, <span class="number">2</span>)]</span><br><span class="line">    y0 = FFT(P0)</span><br><span class="line">    y1 = FFT(P1)</span><br><span class="line">    y = [<span class="number">0</span>] * n</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n // <span class="number">2</span>):</span><br><span class="line">        y[k] = y0[k] + w * y1[k]</span><br><span class="line">        y[k + n // <span class="number">2</span>] = y0[k] - w * y1[k]</span><br><span class="line">        w *= wn</span><br><span class="line">    <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><h3 id="IFFT-Algorithm"><a href="#IFFT-Algorithm" class="headerlink" title="IFFT Algorithm"></a>IFFT Algorithm</h3><p>对于点值计算，其实就是计算一个矩阵乘法：</p><script type="math/tex; mode=display">\begin{bmatrix}y_0\\y_1\\\vdots\\y_{n-1}\end{bmatrix}=\begin{bmatrix}1 & 1 & \cdots & 1\\1 & w_n & \cdots & w_n^{n-1}\\\vdots & \vdots & \ddots & \vdots\\w_n^{n-1} & w_n^{2(n-1)} & \cdots & w_n^{(n-1)(n-1)}\end{bmatrix}\begin{bmatrix}a_0\\a_1\\\vdots\\a_{n-1}\end{bmatrix}</script><p>中间的范德蒙矩阵就是一个DFT矩阵，有了正向的DFT，我们就可以通过逆矩阵来计算逆DFT，即IFFT，即</p><script type="math/tex; mode=display">\begin{bmatrix}a_0\\a_1\\\vdots\\a_{n-1}\end{bmatrix}=\frac{1}{n}\begin{bmatrix}1 & 1 & \cdots & 1\\1 & w_n^{-1} & \cdots & w_n^{-(n-1)}\\\vdots & \vdots & \ddots & \vdots\\w_n^{-(n-1)} & w_n^{-2(n-1)} & \cdots & w_n^{-(n-1)(n-1)}\end{bmatrix}\begin{bmatrix}y_0\\y_1\\\vdots\\y_{n-1}\end{bmatrix}</script><p>这样我们就可以通过IFFT来将点值表示的多项式转化为系数表示的多项式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">IFFT_in</span>(<span class="params">P</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(P)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> P</span><br><span class="line">    w = <span class="number">1</span></span><br><span class="line">    wn = cmath.exp(-<span class="number">2</span> * cmath.pi * <span class="number">1j</span> / n)</span><br><span class="line">    P0 = [P[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n, <span class="number">2</span>)]</span><br><span class="line">    P1 = [P[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n, <span class="number">2</span>)]</span><br><span class="line">    y0 = IFFT(P0)</span><br><span class="line">    y1 = IFFT(P1)</span><br><span class="line">    y = [<span class="number">0</span>] * n</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n // <span class="number">2</span>):</span><br><span class="line">        y[k] = y0[k] + w * y1[k]</span><br><span class="line">        y[k + n // <span class="number">2</span>] = y0[k] - w * y1[k]</span><br><span class="line">        w *= wn</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">IFFT</span>(<span class="params">P</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(P)</span><br><span class="line">    y = IFFT_in(P)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        y[i] /= n</span><br><span class="line">    <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><h3 id="蝴蝶变换"><a href="#蝴蝶变换" class="headerlink" title="蝴蝶变换"></a>蝴蝶变换</h3><p>蝴蝶变换是一个很简单的东西，其实就是我们分治的顺序转换为二进制之后，发现每一个数都是其二进制反过来。这样我们就可以通过一个循环来计算出所有的点值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rev</span>(<span class="params">i, n</span>):</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n.bit_length() - <span class="number">1</span>):</span><br><span class="line">        result = (result &lt;&lt; <span class="number">1</span>) | (i &amp; <span class="number">1</span>)</span><br><span class="line">        i &gt;&gt;= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">FFT</span>(<span class="params">P, IFFT=<span class="literal">False</span></span>):</span><br><span class="line">    n = <span class="built_in">len</span>(P)</span><br><span class="line">    log_n = n.bit_length() - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Reorder P based on reversed bit indices</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        j = rev(i, n)</span><br><span class="line">        <span class="keyword">if</span> i &lt; j:</span><br><span class="line">            P[i], P[j] = P[j], P[i]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># FFT or IFFT computation</span></span><br><span class="line">    l = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> l &lt;= n:</span><br><span class="line">        angle = (<span class="number">2</span> * cmath.pi / l) * (-<span class="number">1</span> <span class="keyword">if</span> IFFT <span class="keyword">else</span> <span class="number">1</span>)</span><br><span class="line">        wn = cmath.exp(angle * <span class="number">1j</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n, l):</span><br><span class="line">            w = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i, i + l // <span class="number">2</span>):</span><br><span class="line">                u = P[k]</span><br><span class="line">                v = w * P[k + l // <span class="number">2</span>]</span><br><span class="line">                P[k] = u + v</span><br><span class="line">                P[k + l // <span class="number">2</span>] = u - v</span><br><span class="line">                w *= wn</span><br><span class="line">        l *= <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Normalize if it&#x27;s IFFT</span></span><br><span class="line">    <span class="keyword">if</span> IFFT:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            P[i] /= n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> P</span><br></pre></td></tr></table></figure><h2 id="NTT-Number-Theoretic-Transform"><a href="#NTT-Number-Theoretic-Transform" class="headerlink" title="NTT-Number Theoretic Transform"></a>NTT-Number Theoretic Transform</h2><p>NTT是FFT的一种变种，其实质是在模数为 $p$ 的情况下，将FFT的复数域转化为整数域。就是将单位根 $w_n$ 替换为 $g$，其中 $g$ 是模数 $p$ 的原根。这样我们就可以在整数域上进行FFT的计算，此处不再赘述。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] <a href="https://www.cnblogs.com/Ning-H/p/12072626.html">https://www.cnblogs.com/Ning-H/p/12072626.html</a><br>[2] <a href="https://www.cnblogs.com/Ning-H/p/13693580.html">https://www.cnblogs.com/Ning-H/p/13693580.html</a><br>[3] <a href="https://www.cnblogs.com/pam-sh/p/15976275.html">https://www.cnblogs.com/pam-sh/p/15976275.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Mathematics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cyclotomic polynomial</title>
      <link href="/2024/08/12/Cyclotomic-polynomial/"/>
      <url>/2024/08/12/Cyclotomic-polynomial/</url>
      
        <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>在复数域 $\mathbb{C}$ 中，多项式 $x^n-1$ 有 $n$ 个根： $\cos \frac{2 \pi k}{n}+\mathrm{i} \sin \frac{2 \pi k}{n}, k=0,1, \cdots, n-1$ 。由 Euler 公式，可以写作 $\mathrm{e}^{2 \pi i k / n}=\exp \frac{2 \pi \mathrm{i} k}{n}$ 。<br>以下为了方便，记 $\omega_n=\exp \frac{2 \pi i}{n}$ ，则 $\omega_n^k=\left(\omega_n\right)^k=\exp \frac{2 \pi i k}{n}$ 。在上下文已知的情况下，可以用 $\omega$ 代替 $\omega_n$ （在某些文献中，用 $\varepsilon$ 表达相同的含义）。</p><p>根据上述记号， $x^n-1$ 的 $n$ 个根可以记作 $1, \omega, \omega^2, \cdots, \omega^{n-1}$<br>因此, 由 <a href="https://en.wikipedia.org/wiki/Vieta%27s_formulas">Vieta 定理</a>（根与系数的关系），可以得到<br>    性质 1.1: $x^n-1=(x-1)(x-\omega)\left(x-\omega^2\right) \cdots\left(x-\omega^{n-1}\right)$<br>由初中的因式分解技巧，有 $x^n-1=(x-1)\left(x^{n-1}+x^{n-2}+\cdots+x+1\right)$ ，于是就有<br>    推论 1.1: $x^{n-1}+x^{n-2}+\cdots+x+1=(x-\omega)\left(x-\omega^2\right) \cdots\left(x-\omega^{n-1}\right)$<br>在上式中代入任何一个 $\omega_n^i$, 即可得到：<br>    推论 1.2: </p><script type="math/tex; mode=display">1 + \omega_n^k + \omega_n^{2k} + \cdots + \omega_n^{(n-1)k} = \begin{cases}0 & \text{if } n \nmid k \\n & \text{if } n \mid k\end{cases}</script><h2 id="单位根群"><a href="#单位根群" class="headerlink" title="单位根群"></a>单位根群</h2><p>由公式 $\omega_n^k=\exp\frac{2\pi\mathrm{i}k}{n}$ 得知，$1, \omega_n, \omega_n^2, \cdots, \omega_n^{n-1}$ 关于乘法运算$\cdot$构成了一个 $n$ 阶循环群 $\omega_n$ 被称为<strong>单位根群 (Group of root or unity)</strong>，其中 $\omega_n$ 是 $\omega_n$ 的一个生成元。<br>从而有 $\omega_n^a \cdot \omega_n^b=\omega_n^{a+b},\left(\omega_n^a\right)^b=\omega_n^{a b}, \omega_n^k=\omega_{\lambda n}^{\lambda k}$ ，以及特殊地 $\overline{\omega_n^k}=\omega_n^{-k}$<br>提到群，自然就会想到它的生成元。那哪些元素会成为它的生成元呢？<br>如果一个单位根, 比如 $\omega_6^2=\frac{-1+\sqrt{3} \mathrm{i}}{2}$, 它其实也是一个 3 次的单位根, 因此它所生成的所有单位根都是 3 次的, 而不会生成 $\omega_6=\frac{1+\sqrt{3} \mathrm{i}}{2} 。$<br>由有限循环群的结论， $\omega_n^k$ 是 $\omega_n$ 的生成元，当且仅当 $n \perp k$ ，即 $(n, k)=1$ 。因此，这些满足 $n \perp k$ 的单位根 $\omega_n^k$ 有着特殊的性质，这就是我们即将讨论的重点。<br>    辨析：<br>    <strong>单位根:</strong> $n$ 阶单位根是满足 $ x^n = 1$  的复数根，这些根在复平面上均匀分布在单位圆上。单位根的一般形式为 $\omega_n^k$，其中 $\omega_n = e^{2\pi i / n}$  是一个主 $n$ 阶单位根，而  $k$  是从 $0$ 到  $n-1$  的整数。<br>    <strong>本原单位根</strong>: 一个 $n$ 阶本原单位根是一种特殊的单位根，它的任意次幂（除了  $n$  的倍数次）都不等于 $1$。具体地，如果 $\omega_n^k$ 是一个 $n$ 阶的本原单位根，那么对于任意非零整数 $m &lt; n$ ，都有 $(\omega_n^k)^m \neq 1$。</p><h2 id="分圆多项式"><a href="#分圆多项式" class="headerlink" title="分圆多项式"></a>分圆多项式</h2><p>如果一个 $n$ 阶单位根 $\omega_n^k$, 满足对于任意的 $i=1,2, \cdots, n-1, \omega_n^{k-i} \neq 1$ (即 $\omega_n^k$ 是群 $\omega_n$ 的生成元), 则称 $n$ 阶单位根 $\omega_n^k$ 是<strong>本原的 (Primitive)</strong>, $\omega_n^k$ 称为<strong>本原单位根 (Primitive root of unity)</strong>, 简称<strong>原根</strong>。<br>    定理 3.1: $\omega_n^k$ 是 $n$ 阶本原单位根的充要条件是 $n \perp k$ 。<br>由定理3.1，可知 $n$ 阶本原单位根恰有 $\phi(n)$ 个<br>上面提到过, 以所有 $n$ 阶单位根为根的多项式为 $x^n-1$， 那么以所有 $\phi(n)$ 个 $n$ 阶本原单位根为根的多项式又有什么样的性质呢？这就是我们接下来要提到的分圆多项式。<br>定义<strong>分圆多项式 (Cyclotomic polynomial)</strong> 所有以 $n$ 阶本原单位根为单根的首一多项式, 记作 $\Phi_n(x)$, 即</p><script type="math/tex; mode=display">\Phi_n(x)=\prod_{\substack{1 \leq k \leq n,(k, n)=1}}\left(x-\omega_n^{\star}\right)</script><p>注意到 $n$ 个单位根将复平面上的单位圆 $|z|=1$ 等分成了 $n$ 等分, 因此得名为<a href="https://zh.wikipedia.org/wiki/分圆多项式">分圆多项式 (Cyclotomic)</a>。<br>由于 $n$ 阶本原单位根一共有 $\phi(n)$ 个, 因此 $n$ 阶分圆多项式的次数 $\operatorname{deg} \Phi_n(x)=\phi(n)$, 这解释了为什么分圆多项式用 $\Phi_n(x)$ 表示。<br>分圆多项式的一个最基础最重要的定理由下面的定理 3.2 给出。<br>定理 3.2: $\prod_{d|n} \Phi_d(x)=x^n-1 。$<br>证明：<br>证明这个定理之前，我们比较两边的次数，可以发现一个有趣的事实：$\sum_{d|n}\phi(d)=n$，这个的理解笔者刚学抽代的时候就有点迷糊，先给出该定理的证明（记录一下），之后再给出定理3.2的证明</p><pre><code>1. 如果 $n=1$，$\phi(n)=\phi(1)=1=n$2. 如果 $n$ 是质数，$\phi(n) = n-1$，因此有 $\phi(n)+\phi(1)=n$3. 如果 $n$ 是一个质数的幂，即$n=p^k$，则有$\sum_&#123;d \mid n&#125; \phi(d)=\sum_&#123;i=0&#125;^k \phi\left(p^i\right)=\sum_&#123;i=1&#125;^k p^&#123;i-1&#125;(p-1)+1=p^k$4. 如果 $n$ 是任意整数，则由整数环是唯一分解整环可得 $n=p_1^&#123;k_1&#125; p_2^&#123;k_2&#125; p_3^&#123;k_3&#125;\dots p_n^&#123;k_n&#125;$，有$\sum_&#123;d|n&#125;\phi(d)=\sum_&#123;i_1=0&#125;^&#123;k_1&#125;\sum_&#123;i_2=0&#125;^&#123;k_2&#125;\dots\sum_&#123;i_n=0&#125;^&#123;k_n&#125;\phi(p_1^&#123;i_1&#125; p_2^&#123;i_2&#125; p_3^&#123;i_3&#125;\dots p_n^&#123;i_n&#125;)=n(相互独立互质，利用欧拉函数的积性)$</code></pre><p>接下来我们证明定理3.2<br>给定一个 $n$ 阶单位根 $\omega_n^k$, 我们定义 $d=\operatorname{gcd}(n, k)$ 。这意味着我们可以将 $n$ 和 $k$ 分别写为 $n=n_1d$ 和 $k=k_1 d$, 其中 $\operatorname{gcd}\left(n_1, k_1\right)=1$ 。因此, $\omega_n^k=\omega_{n_1 d}^{k_1 d}=\left(\omega_{n_1 d}^d\right)^{k_1}=\omega_{n}^{k_1}$ 。这里 $\omega_{n_1}^{k_1}$ 是一个 $n_1$ 阶单位根<br>由于 $n_1$ 和 $k_1$ 互质, 所以 $\omega_{n_1}^{k_1}$ 实际上是一个 $n_1$ 阶的本原单位根。这表明, 从任意 $n$ 阶单位根出发, 通过适当的因子分解和简化, 总能找到一个相对 “更原始” 的单位根, 即某个较小阶数的本原单位根<br><strong>互斥性</strong>：对于 $n$ 的不同因数 $d$ 和 $d^{\prime}$, 其中 $d \neq d^{\prime}, d$ 阶的本原单位根和 $d^{\prime}$ 阶的本原单位根是不同的。本原单位根的定义保证了它不能通过较小的幂次得到 $1$ , 这意味着两个不同阶数的本原单位根不可能相等。<br>对于 $n$ 的每一个因数 $d$，一个 $d$ 阶的本原单位根 $\omega_d^e$ (其中 $e$ 是小于 $d$ 并与 $d$ 互质的整数), 也是一个 $n$ 阶单位根, 因为 $\omega_d^e=\omega_{d /(n / d)}^{e(n / d)}=\omega_n^{e(n / d)}$<br>从以上分析可知，所有 $n$ 的因数 $d$ 对应的 $d$ 阶本原单位根的乘积实际上构成了多项式 $x^n-1$ 的根（性质1.1）。因为 $x^n-1$ 的根包括了所有 $n$ 阶单位根, 而这些单位根又可以通过本原单位根表示。</p><p>在定理 3.2 的等式两端代入 $n=p$ ( $p$ 是素数), 由于 $p$ 的因子只有 1 和 $p$, 就有 $\Phi_1(x) \Phi_p(x)=x^p-1$, 由于 $\Phi_1(x)=x-1$, 因此我们得到了</p><script type="math/tex; mode=display">\Phi_p(x)=\frac{x^p-1}{x-1}=x^{p-1}+x^{p-2}+\cdots+1</script><p>当 $n$ 比较小时, $\Phi_n(x)$ 的性状如下:</p><script type="math/tex; mode=display">\begin{aligned}& \Phi_1(x)=x-1 \\& \Phi_2(x)=x+1 \\& \Phi_3(x)=x^2+x+1 \\& \Phi_4(x)=x^2+1 \\& \Phi_5(x)=x^4+x^3+x^2+x+1 \\& \Phi_6(x)=x^2-x+1 \\& \Phi_7(x)=x^6+x^5+x^4+x^3+x^2+x+1 \\& \Phi_8(x)=x^4+1 \\& \Phi_9(x)=x^6+x^3+1 \\& \Phi_{10}(x)=x^4-x^3+x^2-x+1 \\& \Phi_{11}(x)=x^{10}+x^9+x^8+x^7+x^6+x^5+x^4+x^3+x^2+x+1 \\& \Phi_{12}(x)=x^4-x^2+1 \\& \Phi_{13}(x)=x^{12}+x^{11}+x^{10}+x^9+x^8+x^7+x^6+x^5+x^4+x^3+x^2+x+1 \\& \Phi_{14}(x)=x^6-x^5+x^4-x^3+x^2-x+1 \\& \Phi_{15}(x)=x^8-x^7+x^5-x^4+x^3-x+1 \\& \Phi_{16}(x)=x^8+1 \\& \Phi_{17}(x)=x^{16}+x^{15}+x^{14}+x^{13}+x^{12}+x^{11}+x^{10}+x^9+x^8+x^7+x^6+x^5+x^4+x^3+x^2+x+1 \\& \Phi_{18}(x)=x^6-x^3+1 \\& \Phi_{19}(x)=x^{18}+x^{17}+x^{16}+x^{15}+x^{14}+x^{13}+x^{12}+x^{11}+x^{10}+x^9+x^8+x^7+x^6+x^5+x^4+x^3+x^2+x+1 \\& \Phi_{20}(x)=x^8-x^6+x^4-x^2+1 \\& \Phi_{21}(x)=x^{12}-x^{11}+x^9-x^8+x^6-x^4+x^3-x+1 \\& \Phi_{22}(x)=x^{10}-x^9+x^8-x^7+x^6-x^5+x^4-x^3+x^2-x+1 \\& \Phi_{23}(x)=x^{22}+x^{21}+x^{20}+x^{19}+x^{18}+x^{17}+x^{16}+x^{15}+x^{14}+x^{13}+x^{12}+x^{11} \\& \quad+x^{10}+x^9+x^8+x^7+x^6+x^5+x^4+x^3+x^2+x+1 \\& \Phi_{24}(x)=x^8-x^4+1 \\& \Phi_{25}(x)=x^{20}+x^{15}+x^{10}+x^5+1 \\& \Phi_{26}(x)=x^{12}-x^{11}+x^{10}-x^9+x^8-x^7+x^6-x^5+x^4-x^3+x^2-x+1 \\& \Phi_{27}(x)=x^{18}+x^9+1 \\& \Phi_{28}(x)=x^{12}-x^{10}+x^8-x^6+x^4-x^2+1 \\& \Phi_{29}(x)=x^{28}+x^{27}+x^{26}+x^{25}+x^{24}+x^{23}+x^{22}+x^{21}+x^{20}+x^{19}+x^{18}+x^{17}+x^{16}+x^{15}+x^{14} \\& \quad+x^{13}+x^{12}+x^{11}+x^{10}+x^9+x^8+x^7+x^6+x^5+x^4+x^3+x^2+x+1 \\& \Phi_{30}(x)=x^8+x^7-x^5-x^4-x^3+x+1\end{aligned}</script><p>直觉告诉你, 分圆多项式的系数一定在 $\{-1,0,1\}$ 的范围中 !<br>然而这却是假的。当 $n=105$ 时,</p><script type="math/tex; mode=display">\begin{aligned}\Phi_{105}(x) & =x^{48}+x^{47}+x^{46}-x^{43}-x^{42}-2 x^{41}-x^{40}-x^{39}+x^{36}+x^{35}+x^{34}+x^{33}+x^{32}+x^{31}-x^{28}-x^{26}-x^{24}-x^{22}-x^{20} \\& +x^{17}+x^{16}+x^{15}+x^{14}+x^{13}+x^{12}-x^9-x^8-2 x^7-x^6-x^5+x^2+x+1\end{aligned}</script><p>进一步, 当 $n=463505=5 \times 7 \times 17 \times 19 \times 41$ 时, $\Phi_n(x)$ 的绝对值最大的系数竟有 $-17310!$ 这也可以说明分圆多项式在 $n$ 较大时的增长速度是非常迅猛的。<br>不过，虽然分圆多项式的系数很大，但是我们还是可以非常容易地求出它的值。因为如果对定理 3.2 的等式两端取对数，我们就能得到</p><script type="math/tex; mode=display">\log \left(x^n-1\right)=\sum_{d, n} \log \Phi_d(x)</script><p>可以看出，这是一个 Möbius 变换 (Dirichlet 前缀和) 的形式。因此，我们尝试使用 Möbius 反转变换，即</p><script type="math/tex; mode=display">\log \Phi_n(x)=\sum_{d \mid n} \mu\left(\frac{n}{d}\right) \cdot \log \left(x^d-1\right)</script><p>两边再取指数, 就有</p><script type="math/tex; mode=display">\Phi_n(x)=\prod_{d \mid n}\left(x^d-1\right)^{\mu(n / d)}</script><p>于是我们就得到了一个计算 $\Phi_n(x)$ 的表达式。<br>而定理 3.2 中的式子是一个分解式，所有的分圆多项式都是在 $\mathbb{Z}$ 中不可约 (irreducible) 的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://yhx-12243.github.io/OI-transit/memos/17.html#mjx-eqn-2">https://yhx-12243.github.io/OI-transit/memos/17.html#mjx-eqn-2</a><br>[2] <a href="https://blog.csdn.net/ADjky/article/details/61198817">https://blog.csdn.net/ADjky/article/details/61198817</a></p><!-- https://thea-r.github.io/2018/07/01/如何在Hexo中渲染公式/ -->]]></content>
      
      
      
        <tags>
            
            <tag> Mathematics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux环境变量配置文件</title>
      <link href="/2024/08/03/Linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
      <url>/2024/08/03/Linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux环境变量配置文件"><a href="#Linux环境变量配置文件" class="headerlink" title="Linux环境变量配置文件"></a>Linux环境变量配置文件</h1><p>笔者最近在配置服务器环境，第一次仔细琢磨了一下Linux的几个环境变量配置文件，遂（以Ubuntu22.04为例）写下这一篇博客：</p><h2 id="Linux环境变量"><a href="#Linux环境变量" class="headerlink" title="Linux环境变量"></a>Linux环境变量</h2><p>在自定义安装软件的时候，经常需要配置环境变量：</p><ul><li><code>export</code>命令显示当前系统定义的所有环境变量</li><li><code>echo $PATH</code>命令输出当前的<code>PATH</code>环境变量的值</li></ul><h3 id="Linux环境变量配置方法一：export-PATH"><a href="#Linux环境变量配置方法一：export-PATH" class="headerlink" title="Linux环境变量配置方法一：export PATH"></a>Linux环境变量配置方法一：<code>export PATH</code></h3><p>使用<code>export</code>命令直接修改<code>PATH</code>的值，使用该方法立即生效，但只在当前终端有效，切换终端后即失效，配置的环境变量中不要忘了加上原来的配置，即<code>$PATH</code>部分，避免覆盖原来配置。</p><h3 id="Linux环境变量配置方法二：修改配置文件"><a href="#Linux环境变量配置方法二：修改配置文件" class="headerlink" title="Linux环境变量配置方法二：修改配置文件"></a>Linux环境变量配置方法二：修改配置文件</h3><p>环境变量配置文件有：<code>/etc/profile</code>, <code>/etc/bash.bashrc</code>, <code>/etc/profile.d/*</code>, <code>~/.bashrc</code>, <code>~/.profile</code></p><ul><li><code>/etc/profile</code>：为系统的每个用户设置环境信息，当用户第一次登录(login shell)时，该文件被执行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/profile: system-wide .profile file <span class="keyword">for</span> the Bourne shell (sh(1))</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">and Bourne compatible shells (bash(1), ksh(1), ash(1), ...).</span></span><br><span class="line"></span><br><span class="line">if [ &quot;$&#123;PS1-&#125;&quot; ]; then</span><br><span class="line">  if [ &quot;$&#123;BASH-&#125;&quot; ] &amp;&amp; [ &quot;$BASH&quot; != &quot;/bin/sh&quot; ]; then</span><br><span class="line">    # The file bash.bashrc already sets the default PS1.</span><br><span class="line">    # PS1=&#x27;\h:\w\$ &#x27;</span><br><span class="line">    if [ -f /etc/bash.bashrc ]; then</span><br><span class="line">      . /etc/bash.bashrc</span><br><span class="line">    fi</span><br><span class="line">  else</span><br><span class="line">    if [ &quot;$(id -u)&quot; -eq 0 ]; then</span><br><span class="line">      PS1=&#x27;# &#x27;</span><br><span class="line">    else</span><br><span class="line">      PS1=&#x27;$ &#x27;</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ -d /etc/profile.d ]; then</span><br><span class="line">  for i in /etc/profile.d/*.sh; do</span><br><span class="line">    if [ -r $i ]; then</span><br><span class="line">      . $i</span><br><span class="line">    fi</span><br><span class="line">  done</span><br><span class="line">  unset i</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>我们可以观察到Ubuntu22.04的默认<code>/etc/profile</code>会首先执行<code>/etc/bash.bashrc</code>，之后判断是否为<code>root</code>用户，来确定终端提示符是<code>$</code> 或 <code>#</code>，最后逐个执行<code>/etc/profile.d/</code>中的所有脚本<br>由于 <code>/etc/profile</code>只会在登录时自动执行，因此我们在自动切换用户的时候要注意手动执行<code>source /etc/profile</code></p><ul><li><code>/etc/profile.d</code>：目录中存放的是一些应用程序所需的启动脚本，而这些脚本文件是用来设置一些变量和运行一些初始化过程的。其中包括了颜色、语言、less、vim及which等命令的一些附加设置，其是由<code>/etc/profile</code>调用的，因此也仅在登录时启用。/etc/profile.d/ 比 /etc/profile 好维护。不想要什么变量直接删除/etc/profile.d/下对应的.sh 的shell脚本即可，不用像/etc/profile需要改动此文件。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(base) ubuntu@VM-4-15-ubuntu:~$ ls /etc/profile.d/</span><br><span class="line">01-locale-fix.sh  bash_completion.sh  gawk.sh    Z97-byobu.sh               Z99-cloud-locale-test.sh</span><br><span class="line">apps-bin-path.sh  gawk.csh            qcloud.sh  Z99-cloudinit-warnings.sh</span><br></pre></td></tr></table></figure><ul><li><code>/etc/bash.bashrc</code>：为每一个运行bash shell的用户执行此文件，当bash shell被打开时，该文件被读取。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">System-wide .bashrc file <span class="keyword">for</span> interactive bash(1) shells.</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">To <span class="built_in">enable</span> the settings / commands <span class="keyword">in</span> this file <span class="keyword">for</span> login shells as well,</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">this file has to be sourced <span class="keyword">in</span> /etc/profile.</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">If not running interactively, don<span class="string">&#x27;t do anything</span></span></span><br><span class="line">[ -z &quot;$PS1&quot; ] &amp;&amp; return</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">check the window size after each command and, if necessary,</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">update the values of LINES and COLUMNS.</span></span></span><br><span class="line">shopt -s checkwinsize</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">set variable identifying the chroot you work in (used in the prompt below)</span></span></span><br><span class="line">if [ -z &quot;$&#123;debian_chroot:-&#125;&quot; ] &amp;&amp; [ -r /etc/debian_chroot ]; then</span><br><span class="line">    debian_chroot=$(cat /etc/debian_chroot)</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">set a fancy prompt (non-color, overwrite the one in /etc/profile)</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">but only if not SUDOing and have SUDO_PS1 set; then assume smart user.</span></span></span><br><span class="line">if ! [ -n &quot;$&#123;SUDO_USER&#125;&quot; -a -n &quot;$&#123;SUDO_PS1&#125;&quot; ]; then</span><br><span class="line">  PS1=&#x27;$&#123;debian_chroot:+($debian_chroot)&#125;\u@\h:\w\$ &#x27;</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Commented out, don&#x27;</span>t overwrite xterm -T <span class="string">&quot;title&quot;</span> -n <span class="string">&quot;icontitle&quot;</span> by default.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">If this is an xterm <span class="built_in">set</span> the title to user@host:<span class="built_in">dir</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$TERM</span>&quot;</span> <span class="keyword">in</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">xterm*|rxvt*)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   PROMPT_COMMAND=<span class="string">&#x27;echo -ne &quot;\033]0;$&#123;USER&#125;@$&#123;HOSTNAME&#125;: $&#123;PWD&#125;\007&quot;&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   ;;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">*)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   ;;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">esac</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">enable</span> bash completion <span class="keyword">in</span> interactive shells</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">if</span> ! <span class="built_in">shopt</span> -oq posix; <span class="keyword">then</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> <span class="keyword">if</span> [ -f /usr/share/bash-completion/bash_completion ]; <span class="keyword">then</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   . /usr/share/bash-completion/bash_completion</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> <span class="keyword">elif</span> [ -f /etc/bash_completion ]; <span class="keyword">then</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   . /etc/bash_completion</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> <span class="keyword">fi</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">fi</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">sudo</span> hint</span></span><br><span class="line">if [ ! -e &quot;$HOME/.sudo_as_admin_successful&quot; ] &amp;&amp; [ ! -e &quot;$HOME/.hushlogin&quot; ] ; then</span><br><span class="line">    case &quot; $(groups) &quot; in *\ admin\ *|*\ sudo\ *)</span><br><span class="line">    if [ -x /usr/bin/sudo ]; then</span><br><span class="line">        cat &lt;&lt;-EOF</span><br><span class="line">        To run a command as administrator (user &quot;root&quot;), use &quot;sudo &lt;command&gt;&quot;.</span><br><span class="line">        See &quot;man sudo_root&quot; for details.</span><br><span class="line"></span><br><span class="line">        EOF</span><br><span class="line">    fi</span><br><span class="line">    esac</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">if</span> the command-not-found package is installed, use it</span></span><br><span class="line">if [ -x /usr/lib/command-not-found -o -x /usr/share/command-not-found/command-not-found ]; then</span><br><span class="line">        function command_not_found_handle &#123;</span><br><span class="line">                # check because c-n-f could&#x27;ve been removed in the meantime</span><br><span class="line">                if [ -x /usr/lib/command-not-found ]; then</span><br><span class="line">                   /usr/lib/command-not-found -- &quot;$1&quot;</span><br><span class="line">                   return $?</span><br><span class="line">                elif [ -x /usr/share/command-not-found/command-not-found ]; then</span><br><span class="line">                   /usr/share/command-not-found/command-not-found -- &quot;$1&quot;</span><br><span class="line">                   return $?</span><br><span class="line">                else</span><br><span class="line">                   printf &quot;%s: command not found\n&quot; &quot;$1&quot; &gt;&amp;2</span><br><span class="line">                   return 127</span><br><span class="line">                fi</span><br><span class="line">        &#125;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><ul><li><code>~/.profile</code>：每个用户都可使用该文件输入专用于自己使用的shell信息，当用户登录时，该文件仅仅执行一次。是交互式login 方式进入 bash 运行的。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">~/.profile: executed by the <span class="built_in">command</span> interpreter <span class="keyword">for</span> login shells.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This file is not <span class="built_in">read</span> by bash(1), <span class="keyword">if</span> ~/.bash_profile or ~/.bash_login</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">exists.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">see /usr/share/doc/bash/examples/startup-files <span class="keyword">for</span> examples.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">the files are located <span class="keyword">in</span> the bash-doc package.</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">the default <span class="built_in">umask</span> is <span class="built_in">set</span> <span class="keyword">in</span> /etc/profile; <span class="keyword">for</span> setting the <span class="built_in">umask</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">for</span> ssh logins, install and configure the libpam-umask package.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">umask</span> 022</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">if</span> running bash</span></span><br><span class="line">if [ -n &quot;$BASH_VERSION&quot; ]; then</span><br><span class="line">    # include .bashrc if it exists</span><br><span class="line">    if [ -f &quot;$HOME/.bashrc&quot; ]; then</span><br><span class="line">        . &quot;$HOME/.bashrc&quot;</span><br><span class="line">    fi</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">set</span> PATH so it includes user<span class="string">&#x27;s private bin if it exists</span></span></span><br><span class="line">if [ -d &quot;$HOME/bin&quot; ] ; then</span><br><span class="line">    PATH=&quot;$HOME/bin:$PATH&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">set PATH so it includes user&#x27;</span>s private bin <span class="keyword">if</span> it exists</span></span><br><span class="line">if [ -d &quot;$HOME/.local/bin&quot; ] ; then</span><br><span class="line">    PATH=&quot;$HOME/.local/bin:$PATH&quot;</span><br><span class="line">fi</span><br><span class="line">. &quot;$HOME/.cargo/env&quot;</span><br></pre></td></tr></table></figure><ul><li><code>~/.bashrc</code>：该文件包含专用于你的bash shell的bash信息，当登录时以及每次打开新的shell时，该文件被读取。交互式non-login 方式进入 bash 运行的。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">~/.profile: executed by the <span class="built_in">command</span> interpreter <span class="keyword">for</span> login shells.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This file is not <span class="built_in">read</span> by bash(1), <span class="keyword">if</span> ~/.bash_profile or ~/.bash_login</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">exists.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">see /usr/share/doc/bash/examples/startup-files <span class="keyword">for</span> examples.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">the files are located <span class="keyword">in</span> the bash-doc package.</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">the default <span class="built_in">umask</span> is <span class="built_in">set</span> <span class="keyword">in</span> /etc/profile; <span class="keyword">for</span> setting the <span class="built_in">umask</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">for</span> ssh logins, install and configure the libpam-umask package.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">umask</span> 022</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">if</span> running bash</span></span><br><span class="line">if [ -n &quot;$BASH_VERSION&quot; ]; then</span><br><span class="line">    # include .bashrc if it exists</span><br><span class="line">    if [ -f &quot;$HOME/.bashrc&quot; ]; then</span><br><span class="line">        . &quot;$HOME/.bashrc&quot;</span><br><span class="line">    fi</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">set</span> PATH so it includes user<span class="string">&#x27;s private bin if it exists</span></span></span><br><span class="line">if [ -d &quot;$HOME/bin&quot; ] ; then</span><br><span class="line">    PATH=&quot;$HOME/bin:$PATH&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">set PATH so it includes user&#x27;</span>s private bin <span class="keyword">if</span> it exists</span></span><br><span class="line">if [ -d &quot;$HOME/.local/bin&quot; ] ; then</span><br><span class="line">    PATH=&quot;$HOME/.local/bin:$PATH&quot;</span><br><span class="line">fi</span><br><span class="line">. &quot;$HOME/.cargo/env&quot;</span><br><span class="line">(base) ubuntu@VM-4-15-ubuntu:~$ cat ~/.bashrc </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">~/.bashrc: executed by bash(1) <span class="keyword">for</span> non-login shells.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">see /usr/share/doc/bash/examples/startup-files (<span class="keyword">in</span> the package bash-doc)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">for</span> examples</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">If not running interactively, don<span class="string">&#x27;t do anything</span></span></span><br><span class="line">case $- in</span><br><span class="line">    *i*) ;;</span><br><span class="line">      *) return;;</span><br><span class="line">esac</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">don&#x27;</span>t put duplicate lines or lines starting with space <span class="keyword">in</span> the <span class="built_in">history</span>.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">See bash(1) <span class="keyword">for</span> more options</span></span><br><span class="line">HISTCONTROL=ignoreboth</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">append to the <span class="built_in">history</span> file, don<span class="string">&#x27;t overwrite it</span></span></span><br><span class="line">shopt -s histappend</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">for setting history length see HISTSIZE and HISTFILESIZE in bash(1)</span></span></span><br><span class="line">HISTSIZE=1000</span><br><span class="line">HISTFILESIZE=2000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">check the window size after each command and, if necessary,</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">update the values of LINES and COLUMNS.</span></span></span><br><span class="line">shopt -s checkwinsize</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">If set, the pattern &quot;**&quot; used in a pathname expansion context will</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">match all files and zero or more directories and subdirectories.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">shopt -s globstar</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">make less more friendly for non-text input files, see lesspipe(1)</span></span></span><br><span class="line">[ -x /usr/bin/lesspipe ] &amp;&amp; eval &quot;$(SHELL=/bin/sh lesspipe)&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">set variable identifying the chroot you work in (used in the prompt below)</span></span></span><br><span class="line">if [ -z &quot;$&#123;debian_chroot:-&#125;&quot; ] &amp;&amp; [ -r /etc/debian_chroot ]; then</span><br><span class="line">    debian_chroot=$(cat /etc/debian_chroot)</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">set a fancy prompt (non-color, unless we know we &quot;want&quot; color)</span></span></span><br><span class="line">case &quot;$TERM&quot; in</span><br><span class="line">    xterm-color|*-256color) color_prompt=yes;;</span><br><span class="line">esac</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">uncomment for a colored prompt, if the terminal has the capability; turned</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">off by default to not distract the user: the focus in a terminal window</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">should be on the output of commands, not on the prompt</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">force_color_prompt=yes</span></span></span><br><span class="line"></span><br><span class="line">if [ -n &quot;$force_color_prompt&quot; ]; then</span><br><span class="line">    if [ -x /usr/bin/tput ] &amp;&amp; tput setaf 1 &gt;&amp;/dev/null; then</span><br><span class="line">        # We have color support; assume it&#x27;s compliant with Ecma-48</span><br><span class="line">        # (ISO/IEC-6429). (Lack of such support is extremely rare, and such</span><br><span class="line">        # a case would tend to support setf rather than setaf.)</span><br><span class="line">        color_prompt=yes</span><br><span class="line">    else</span><br><span class="line">        color_prompt=</span><br><span class="line">    fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ &quot;$color_prompt&quot; = yes ]; then</span><br><span class="line">    PS1=&#x27;$&#123;debian_chroot:+($debian_chroot)&#125;\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ &#x27;</span><br><span class="line">else</span><br><span class="line">    PS1=&#x27;$&#123;debian_chroot:+($debian_chroot)&#125;\u@\h:\w\$ &#x27;</span><br><span class="line">fi</span><br><span class="line">unset color_prompt force_color_prompt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">If this is an xterm set the title to user@host:dir</span></span></span><br><span class="line">case &quot;$TERM&quot; in</span><br><span class="line">xterm*|rxvt*)</span><br><span class="line">    PS1=&quot;\[\e]0;$&#123;debian_chroot:+($debian_chroot)&#125;\u@\h: \w\a\]$PS1&quot;</span><br><span class="line">    ;;</span><br><span class="line">*)</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">enable color support of ls and also add handy aliases</span></span></span><br><span class="line">if [ -x /usr/bin/dircolors ]; then</span><br><span class="line">    test -r ~/.dircolors &amp;&amp; eval &quot;$(dircolors -b ~/.dircolors)&quot; || eval &quot;$(dircolors -b)&quot;</span><br><span class="line">    alias ls=&#x27;ls --color=auto&#x27;</span><br><span class="line">    #alias dir=&#x27;dir --color=auto&#x27;</span><br><span class="line">    #alias vdir=&#x27;vdir --color=auto&#x27;</span><br><span class="line"></span><br><span class="line">    alias grep=&#x27;grep --color=auto&#x27;</span><br><span class="line">    alias fgrep=&#x27;fgrep --color=auto&#x27;</span><br><span class="line">    alias egrep=&#x27;egrep --color=auto&#x27;</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">colored GCC warnings and errors</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">export GCC_COLORS=&#x27;</span>error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01<span class="string">&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">some more ls aliases</span></span></span><br><span class="line">alias ll=&#x27;ls -alF&#x27;</span><br><span class="line">alias la=&#x27;ls -A&#x27;</span><br><span class="line">alias l=&#x27;ls -CF&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Add an &quot;alert&quot; alias for long running commands.  Use like so:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">  sleep 10; alert</span></span></span><br><span class="line">alias alert=&#x27;notify-send --urgency=low -i &quot;$([ $? = 0 ] &amp;&amp; echo terminal || echo error)&quot; &quot;$(history|tail -n1|sed -e &#x27;\&#x27;&#x27;s/^\s*[0-9]\+\s*//;s/[;&amp;|]\s*alert$//&#x27;\&#x27;&#x27;)&quot;&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Alias definitions.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">You may want to put all your additions into a separate file like</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">~/.bash_aliases, instead of adding them here directly.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">See /usr/share/doc/bash-doc/examples in the bash-doc package.</span></span></span><br><span class="line"></span><br><span class="line">if [ -f ~/.bash_aliases ]; then</span><br><span class="line">    . ~/.bash_aliases</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">enable programmable completion features (you don&#x27;</span>t need to <span class="built_in">enable</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">this, <span class="keyword">if</span> it<span class="string">&#x27;s already enabled in /etc/bash.bashrc and /etc/profile</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">sources /etc/bash.bashrc).</span></span></span><br><span class="line">if ! shopt -oq posix; then</span><br><span class="line">  if [ -f /usr/share/bash-completion/bash_completion ]; then</span><br><span class="line">    . /usr/share/bash-completion/bash_completion</span><br><span class="line">  elif [ -f /etc/bash_completion ]; then</span><br><span class="line">    . /etc/bash_completion</span><br><span class="line">  fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><ul><li><code>~/.bash_logout</code>：当每次退出系统(退出bash shell)时，执行该文件。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">~/.bash_logout: executed by bash(1) when login shell exits.</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">when leaving the console clear the screen to increase privacy</span></span><br><span class="line"></span><br><span class="line">if [ &quot;$SHLVL&quot; = 1 ]; then</span><br><span class="line">    [ -x /usr/bin/clear_console ] &amp;&amp; /usr/bin/clear_console -q</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="在登录Linux时要执行文件的过程如下："><a href="#在登录Linux时要执行文件的过程如下：" class="headerlink" title="在登录Linux时要执行文件的过程如下："></a>在登录Linux时要执行文件的过程如下：</h3><p>在刚登录Linux时，首先启动<code>/etc/profile</code> 文件，然后再启动用户目录下的<code>~/.bash_profile</code>、<code>~/.bash_login</code>或<code>~/.profile</code>文件中的其中一个(根据不同的linux操作系统的不同，命名不一样)</p><p>如果<code>~/.bash_profile</code>文件存在的话，一般还会执行 <code>~/.bashrc</code>文件因为在 <code>~/.bash_profile</code>文件中一般会有下面的代码：<code>if [ -f ~/.bashrc ] ; then . ./bashrc fi ~/.bashrc</code>。最后，在退出shell时，还会执行<code>~/.bash_logout</code>文件。</p><p>执行顺序为：<br><code>/etc/profile</code> -&gt; <code>/etc/bash.bashrc</code> -&gt; <code>/etc/profile.d</code> -&gt; <code>~/.profile</code> -&gt; <code>~/.bashrc</code> -&gt; <code>~/.bash_logout</code></p><p>笔者在写的时候也注意到貌似和网上一些介绍不太一样，但是这是笔者所观察到的情况，也没有去查阅Linux官方文档，因此可以辩证地看待。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linear Error-Correcting Codes</title>
      <link href="/2024/07/01/Linear-Error-Correcting-Codes/"/>
      <url>/2024/07/01/Linear-Error-Correcting-Codes/</url>
      
        <content type="html"><![CDATA[<p>我们希望通过通道可靠地将消息（以位表示）传输到目的地。传输过程中可能会出现错误，我们希望检测和纠正这些传输错误。为了做到这一点，我们必须在传输的消息中引入一些冗余。<br>我们看到Shannon’s Noisy Coding Theorem告诉我们，如果冗余度高于一定水平（受通道噪音约束），那么我们可以随着块长度的增加将错误概率（检测到发送的错误消息）减少到零。<br>该证明是基于随机编码，这不是很实用。为了易于编码和解码，我们的编码/解码功能需要优良的结构。我们将研究一类称为线性分组码的代码，因为它们的结构提供了几个优点。线性性将使我们更容易地分析代码的错误纠正能力。此外，使用矩阵来编码/解码消息比随机码本容易得多，并且可以简洁地描述代码。</p><p>两个概念：</p><ul><li>Error detection：编码可以检测错误，但我们不知道错误在接收序列中的位置。</li><li>Error correction：我们知道错误在哪里，并且可以纠正错误的位位置。</li></ul><p>在代码最多可以纠正t个错误的情况下，如果序列包含超过t个错误，解码器可能会解码到错误的信息序列。</p><p>任意两个比特串之间的汉明距离$d_H$是2个字符串不同的比特数。例如，码字$c_1=(101101)$和$c_2=(100110)$之间的汉明距离$d_H$是3。表示$d^*$是代码$C$的任何两个不同码字之间的最小汉明距离</p><script type="math/tex; mode=display">D^*=d_{\min }=\min _{c_i \neq c_j} d_H\left(c_i, c_j\right)</script><p>码字之间最小距离为$d^*$的代码可以检测$d^*-1$错误，并可以纠正$\frac{d^*-1}{2}$错误。因此，要纠正一个错误，代码的最小距离必须至少为3。</p><p>线性码意味着$c\left(m+m^{\prime}\right)=c(m)+c\left(m^{\prime}\right)$，因此有<script type="math/tex">c(01101)=c(01000)+c(00100)+c(00001)=c\left(e_2\right)+c\left(e_3\right)+c\left(e_5\right)</script><br>$e_i, 1 \leq i \leq k$构成了消息空间的基础，$e_i$的码字完全描述了线性码。因此，不需要带有$2^k$条目的代码本。我们仅需要一个矩阵即可</p><p>我们可以假设生成矩阵$G$采取特定形式。事实上，如果我们在$G$上执行基本行操作（在$Z_2$上，这意味着我们将一行添加到另一行），我们不会更改代码中的码字集合。我们甚至可以在不从根本上改变代码属性的情况下对列进行排列。因此，使用高斯消除，我们可以假设$G$采取更简单的形式：</p><script type="math/tex; mode=display">G=\left[I_{k \times k} S\right]，</script><p>其中$S$是$k \times(n-k)$。</p><p>假设我们的矩阵$G$生成单纠错代码，因此没有权重1或2的码字，$G$的奇偶校验部分$S$必须满足以下2个条件：</p><ul><li>$S$中每行的权重必须至少为2，因为$I$部分的每一行正好有一个权重。</li><li>没有两行$S$是相同的。否则，将这两行相加将给出一个权重2的码字。</li></ul><p>汉明编码是单个纠错线性块代码，具有$(n, k)=\left(2^m-1,2^m-1-m\right)$，其中$m=n-k$是代码中的检查位数。最简单的非平凡代码是$m=3$，即$(7,4)$ Hamming代码。</p><p>之所以$k=2^m-1-m$</p><pre><code> $2^m$减去汉明重量为0和1的码字</code></pre><p>我们知道如何用任何线性代码进行编码。由消息$m$生成的码字只是$c=m G$。但是解码怎么样？如果没有引入错误，第一个$k$位构成消息。但可能已经引入了错误。当只有一个错误时，正如我们现在所显示的那样，解码很容易。</p><p>对于每个生成器矩阵$G=[I S]$，都有一个奇偶校验矩阵$H$定义</p><script type="math/tex; mode=display">H=\left[\begin{array}{l}S \\ I\end{array}\right]</script><p>由于$S$的大小为$k \times(n-k)$，我们的单位矩阵大小为$(n-k) \times(n-k)$，$H$的大小为$n \times(n-k)$。重要的观察是$G H=S+S=0$，因此$c=m G$满足$c H=m G H=0$。这意味着，如果有错误，并且我们收到了$\tilde{c}=c+e_i$，我们可以通过计算$\tilde{c} H$找到错误$e_i$，因为这应该是$c H+e_i H=e_i H$。因此，$\tilde{c} H$必须是$H$的行之一，该行的索引指示哪个位已损坏。一旦我们知道哪个位已损坏，我们就可以恢复消息。</p>]]></content>
      
      
      
        <tags>
            
            <tag> information theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Moment Generationg Function</title>
      <link href="/2024/05/13/Moment-Generationg-Function/"/>
      <url>/2024/05/13/Moment-Generationg-Function/</url>
      
        <content type="html"><![CDATA[<h1 id="Moment-Generating-Function"><a href="#Moment-Generating-Function" class="headerlink" title="Moment Generating Function"></a>Moment Generating Function</h1><p>“我们需要更多的特征来描述分布，例如峰度，偏度，除了常用的平均值，方差，这些特征统一称为矩，那么有没有一个函数能够计算所有矩呢？当然有，矩母函数，你就可以通过微分来计算各种矩，而不是从定义的积分算，你肯定知道微分比积分容易吧！”</p><h2 id="「矩」（moment）的实际含义"><a href="#「矩」（moment）的实际含义" class="headerlink" title="「矩」（moment）的实际含义"></a>「矩」（moment）的实际含义</h2><h3 id="物理意义"><a href="#物理意义" class="headerlink" title="物理意义"></a>物理意义</h3><p>数学中矩的概念来自物理学。在物理学中，矩是表示距离和物理量乘积的物理量，表征物体的空间分布。由其定义，矩通常需要一个参考点（基点或参考系）来定义距离。如力和参考点距离乘积得到的力矩（或扭矩），原则上任何物理量和距离相乘都会产生<a href="https://www.zhihu.com/search?q=力矩&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A151157559}">力矩</a>，质量，电荷分布等。</p><h3 id="数学意义"><a href="#数学意义" class="headerlink" title="数学意义"></a>数学意义</h3><p>矩是物体形状识别的重要参数指标。在统计学中，矩表征随机量的分布。如一个“<a href="https://www.zhihu.com/search?q=二阶矩&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A151157559}">二阶矩</a>”在一维上可测量其“宽度”，在更高阶的维度上由于其使用于橢球的空间分布，我们还可以对点的云结构进行测量和描述。其他矩用来描述诸如与均值的<a href="https://www.zhihu.com/search?q=偏差分布&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A151157559}">偏差分布</a>情况（偏态），或峰值的分布情况（<a href="https://www.zhihu.com/search?q=峰态&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A151157559}">峰态</a>）</p><p>定义在实数域的实函数相对于值c的n阶矩为：</p><script type="math/tex; mode=display">\mu_n^{\prime}=\int_{-\infty}^{\infty}(x-c)^n f(x) d x</script><p><strong>如果点表示<a href="https://www.zhihu.com/search?q=概率密度&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A151157559}">概率密度</a></strong>，则第零阶矩表示总概率（即1），一阶（原点）矩则表示期望：</p><script type="math/tex; mode=display">E(x)=\int_{-\infty}^{\infty} x f(x) d x</script><p>在方差等定义中，则将<strong>期望</strong>视作矩的中心，因为<strong>中心矩可以更好的体现关于分布形状的信息</strong>，而原点矩则体现的是关于原点的分布状况。</p><script type="math/tex; mode=display">\operatorname{Var}(x)=\int_{-\infty}^{\infty}[x-E(x)]^2 f(x) d x</script><p>高阶矩则用作测量一个分布的<strong>重尾程度</strong>，通常用于金融分析中，比如说极小的概率赔1000w，也极其恐怖。</p><h2 id="矩生成函数（moment-generating-function）"><a href="#矩生成函数（moment-generating-function）" class="headerlink" title="矩生成函数（moment generating function）"></a>矩生成函数（moment generating function）</h2><p>矩生成函数，顾名思义，是用于生成矩的函数。随机变量$X$的矩生成函数定义为：</p><script type="math/tex; mode=display">M_X(t)=\mathbb{E}(e^{tx}),\quad t\in R</script><p>如果 $X$ 具有连续概率密度函数 $f(x)$, 则它的矩生成函数由下式给出:</p><script type="math/tex; mode=display">\begin{aligned}M_X(t) & =\int_{-\infty}^{\infty} e^{t x} f(x) \mathrm{d} x \\& =\int_{-\infty}^{\infty}\left(1+t x+\frac{t^2 x^2}{2!}+\cdots\right) f(x) \mathrm{d} x \\& =1+t m_1+\frac{t^2 m_2}{2!}+\cdots\end{aligned}</script><p>其中 $m_i$ 是第 $i$ 个矩。 $M_X(-t)$ 是 $f(x)$ 的双边拉普拉斯变换。</p><p>对MGF取n次导数，并令t=0，则可以得到n阶矩$E(x^n)$</p><script type="math/tex; mode=display">E\left(X^n\right)=\left.\frac{d^n}{d t^n} M G F_x(t)\right|_{t=0}</script><script type="math/tex; mode=display">\begin{aligned}& E(X)=\left.\frac{d}{d t} M G F_x(t)\right|_{t=0}=M G F_x^{\prime}(0) \\& E\left(X^2\right)=\left.\frac{d^2}{d t^2} M G F_x(t)\right|_{t=0}=M G F_x^{\prime \prime}(0)\end{aligned}</script><p>而求微分肯定比求积分容易，这也就是矩生成函数的意义所在。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Mathematics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>some thoughts about Lipschitz</title>
      <link href="/2024/04/17/%E5%85%B3%E4%BA%8ELipschitz%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2024/04/17/%E5%85%B3%E4%BA%8ELipschitz%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h1 id="关于Lipschitz的思考"><a href="#关于Lipschitz的思考" class="headerlink" title="关于Lipschitz的思考"></a>关于Lipschitz的思考</h1><p>今天在看TFHE论文的过程中，看到了 $\kappa$-Lipschitz的概念</p><p>The notion of Lipschitz function always refers to the $\ell_{\infty}$-distance: a function $f: \mathbb{T}^m \rightarrow \mathbb{T}^n$ is said to be $\kappa$-Lipschitz if $|f(x)-f(y)|_{\infty} \leq \kappa |x-y|_{\infty}$ for all inputs $x, y$, where $|\cdot|_{\infty}$ is the $\ell_{\infty}$ norm.</p><blockquote><p>一个新奇的想法：在学密码学过程中遇到的一些数学概念，或许我们应该去究其本质，看看它原本在数学领域和其他领域的应用，或者说提出的原因，这样更有利于我们理解他的概念</p></blockquote><p>可能是笔者太久没学数学了，看到这样一个形式有点迷糊，甚至有一个奇怪的想法，$x$和$f(x)$量纲不同（考虑到量纲可能是因为选用的是$\infty$范数，现在倒是想不起来为什么会考虑到量纲了）的话，这么限制有什么意义呢？</p><p>之后去查阅了相关资料，发现Lipschitz多用于深度学习领域，并且该概念十分简单易懂。我们把RHS中的$|x-y|_{\infty}$除下来，其实就是斜率的概念</p><script type="math/tex; mode=display">\frac{\|f(x)-f(y)\|_{\infty} }{|x-y\|_{\infty}}\leq \kappa</script><p>这不就是代表$f(x)$这个函数，在任意维度上，斜率最大也不超过$\kappa$​嘛。在TLWE提到这个概念，应该也只是想约束一下error对于明文带来的影响。</p><p>在TLWE中，我们是将Lipschitz套在phase function上使用的，phase的自变量$x$是ciphertext，因变量才是plaintext，因此笔者理解的是给ciphertext加error造成的影响，对于plaintext不大，所以才能正确解密。</p><p>我们可以这样看这个问题，假设密文是$(\pmb{a},b)$，对应的明文是$\mu$，则有$\varphi_s{(\pmb{a},b)}=b-\pmb{a}\pmb{s}=\mu$，我们引入噪声，可以参考TFHE中对于trivial encryption的概念，$(\pmb{0},e)$和$e$，则有$\varphi_s{(\pmb{0},e)}=e-\pmb{0}\pmb{s}=e$</p><p>因此，我们可以有</p><script type="math/tex; mode=display">\frac{\|\varphi_s{(\pmb{a},b)}-\varphi_s{(\pmb{a},b-e)}\|_{\infty} }{|(\pmb{0},e)\|_{\infty}}\leq \kappa</script><script type="math/tex; mode=display">\|\varphi_s{(\pmb{a},b)}-\varphi_s{(\pmb{a},b-e)}\|_{\infty} \leq \kappa{||(\pmb{0},e)\|_{\infty}}</script><p>因此，影响很小</p><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p>[1] <a href="https://zhuanlan.zhihu.com/p/389024283">详细解析深度学习中的 Lipschitz 条件</a></p><p>[2] Chillotti I, Gama N, Georgieva M, et al. TFHE: fast fully homomorphic encryption over the torus[J]. Journal of Cryptology, 2020, 33(1): 34-91.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Mathematics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Conversion between arithmetic circuit and Boolean circuit</title>
      <link href="/2023/12/21/%E7%AE%97%E6%9C%AF%E7%94%B5%E8%B7%AF%E4%B8%8E%E5%B8%83%E5%B0%94%E7%94%B5%E8%B7%AF%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"/>
      <url>/2023/12/21/%E7%AE%97%E6%9C%AF%E7%94%B5%E8%B7%AF%E4%B8%8E%E5%B8%83%E5%B0%94%E7%94%B5%E8%B7%AF%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="布尔电路-to-算术电路"><a href="#布尔电路-to-算术电路" class="headerlink" title="布尔电路 to 算术电路"></a>布尔电路 to 算术电路</h2><p>在$(\mathbb{F},+,\cdot)$上考虑一个函数$f$，该函数可以由大小为多项式的布尔电路在其输入大小上计算，例如，在标准基础$\{ \mathsf{XOR}，\mathsf{AND}，\mathsf{NOT} \}$。要在$\mathbb {F}$上模拟计算，请将$0$编码为$0_ \mathbb {F}$(在$\mathbb {F}$中加法的中性)，将$1$编码为$1_ \mathbb {F}$(乘法的中性)。布尔门可以模拟如下：</p><p>要计算输入$(x，y)$的$\mathsf{OR}$门，返回$x+y - x \cdot y$</p><p>要计算输入$(x，y)$的$\mathsf{AND}$门，返回$x \cdot y$</p><p>要计算输入$(x，y)$的$\mathsf{XOR}$门，返回$x + y-2 \cdot x \cdot y$</p><p>要计算输入$x$的$\mathsf{NOT}$门，请返回$1_ \mathbb{F} -x$。</p><h2 id="算术电路-to-布尔电路"><a href="#算术电路-to-布尔电路" class="headerlink" title="算术电路 to 布尔电路"></a>算术电路 to 布尔电路</h2><p>考虑$\mathbb{F}$的任何元素$x$的二进制分解：$x = \sum_ {i = 0} ^ {\lceil \log | \mathbb {F} || \rceil-1} b_i \cdot 2 ^ i$，$b_i \in \{0_\mathbb{F}，1_\mathbb {F} \}$。</p><ul><li>$\mathbb {F}$上的加法: 通过$\mathsf{XOR}$门得到第$i$位的值，通过$\mathsf{AND}$门得到第$i$位的进位。</li><li>$\mathbb {F}$上的乘法: 通过$\mathsf{AND}$门和上述加法即可实现。</li></ul><p>其实就是模拟我们计算机所做的事情。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>签名算法之DSA,ECDSA和EdDSA</title>
      <link href="/2023/12/12/ECDSA/"/>
      <url>/2023/12/12/ECDSA/</url>
      
        <content type="html"><![CDATA[<p>好记性不如烂笔头，写一篇文章详细记录一下DSA，ECDSA和EdDSA。</p><h1 id="DSA"><a href="#DSA" class="headerlink" title="DSA"></a>DSA</h1><p>数字签名算法（DSA）是用于数字签名的联邦信息处理标准之一，基于模算数和离散对数的复杂度。DSA是Schnorr和ElGamal签名方案的变体。<a href="#refer-anchor-1"><sup>1</sup></a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>DSA算法工作在框架公钥加密、模算数和离散对数问题，这被认为是难解问题。该算法使用由公钥和私钥组成的密钥对。私钥用于生成消息的数字签名，并且可以通过使用签名者的相应公钥来验证这种签名。数字签名提供信息鉴定（接收者可以验证消息的来源），完整性（接收方可以验证消息自签名以来未被修改）和不可否认性（发送方不能错误地声称它们没有签署消息）</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>DSA 算法包含了四种操作：密钥生成、密钥分发、签名、验证</p><h3 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h3><ol><li>选择经核可的 密码散列函数 $H$，在原版的 DSS（Digital Signature Standard）中，$H$ 总是使用 SHA-1，而目前的 DSS 已核可更为安全的 SHA-2 作为散列函数。 假如长度 ${\displaystyle |H|}$ 大于模数长度$N$，则散列函数的输出只有最左边的 $N$ 比特会被使用。</li><li>选择密钥长度 $L$，原版的 DSS 限制 $L$ 必须为 512 到 1024 之间 64 的倍数，NIST 800-57 建议使用长度为 2048 的密钥。</li><li>选择模数长度 $N$ 使得 ${\displaystyle N&lt;L}$ 且 ${\displaystyle N\leq |H|}$，FIPS 186-4 规定 ${\displaystyle (L,N)}$ 必须为 (1024, 160)、(2048, 224)、(2048, 256) 或 (3072, 256) 其中一种。</li><li>选择长度为 $N$ 比特的质数 $q$。</li><li>选择长度为 $L$ 比特的质数 $p$ 使得 $<br>{\displaystyle p-1}$ 为 $q$ 的倍数。</li><li>从 ${\displaystyle \{2\ldots p-2\}}$ 随机选择 $h$。计算 ${\displaystyle g:=h^{(p-1)/q}\mod p}$，当 $g=1$ 时需要重新产生不同的 $h$，通常会使用 ${\displaystyle h=2}$，即使数值很大时仍然可以非常有效率的计算这个模幂。</li></ol><p>算法参数为 $(p,q,g)$，可被不同的用户共享。</p><h4 id="用户密钥"><a href="#用户密钥" class="headerlink" title="用户密钥"></a>用户密钥</h4><p>给定一套算法参数后，第二阶段会为每位用户计算独立密钥组合：</p><ol><li>从 ${\displaystyle \{1\ldots q-1\}}$ 选择随机整数 $x$</li><li>计算 ${\displaystyle y:=g^{x}\mod p}$</li></ol><p>其中<br>$x$ 是私钥、<br>$y$ 是公钥。</p><h3 id="密钥分发"><a href="#密钥分发" class="headerlink" title="密钥分发"></a>密钥分发</h3><p>签名者需要透过可信任的管道发布公钥<br>$y$，并且安全地保护<br>$x$ 不被其他人知道。</p><h3 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h3><p>消息 $m$ 签名流程如下：</p><ol><li>从 ${\displaystyle \{1\ldots q-1\}}$ 选择随机整数 $k$</li><li>计算 ${\displaystyle r:=\left(g^{k}{\bmod {\,}}p\right){\bmod {\,}}q}$，当出现 $r=0$ 状况时重新选择随机数 $k$</li><li>计算 ${\displaystyle s:=\left(k^{-1}\left(H(m)+xr\right)\right){\bmod {\,}}q}$，当出现$s=0$ 状况时重新选择随机数 $k$.</li></ol><p>签名为 ${\displaystyle (r,s)}$ 组合</p><h3 id="验证签名"><a href="#验证签名" class="headerlink" title="验证签名"></a>验证签名</h3><p>以下步骤可以验证 $<br>{\displaystyle \left(r,s\right)}$ 是消息<br>$m$ 的有效签名：</p><ol><li>验证$0 &lt; r &lt; q, 0 &lt; s &lt; q$</li><li>计算$w:=s^{-1} \mod q$ </li><li>计算$u_1:=H(m)\cdot w \mod q$</li><li>计算$u_2:=r\cdot w \mod q$</li><li>计算$v:=(g^{u_1}y^{u_2}\mod p)\mod q$</li></ol><p>只有$v = r$时，签名有效</p><h2 id="Correctness"><a href="#Correctness" class="headerlink" title="Correctness"></a>Correctness</h2><p>因为<script type="math/tex">g = h^{(p-1)/q} \mod p</script>所以 <script type="math/tex">g^q = h^{p-1} =1 \mod q</script></p><p>所以有</p><script type="math/tex; mode=display">\begin{align*}v=&(g^{u_1}y^{u_2}\mod p)\mod q \\=&(g^{H(m)\cdot s^{-1}}y^{r\cdot s^{-1}}\mod p)\mod q\\=&(g^{H(m)\cdot s^{-1}}g^{x\cdot r\cdot s^{-1}}\mod p)\mod q\\=&(g^{H(m)\cdot s^{-1} \,+\, x\cdot r\cdot s^{-1}}\mod p)\mod q\\=&(g^{(H(m) \,+\, x\cdot r)\cdot s^{-1}}\mod p)\mod q\\=&(g^{(H(m) \,+\, xr)\cdot k\cdot {\left(H(m)+xr\right)^{-1}}}\mod p)\mod q\\=&(g^k \mod p) \mod q\\=&r\end{align*}</script><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime, getRandomRange, getRandomNBitInteger, isPrime</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_param</span>(<span class="params">L,N</span>):</span><br><span class="line">    q = getPrime(N)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        t = getRandomNBitInteger(L-N)</span><br><span class="line">        p = t*q + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> p.bit_length() == L <span class="keyword">and</span> isPrime(p):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    h = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        g = <span class="built_in">pow</span>(h,(p-<span class="number">1</span>)//q,p)</span><br><span class="line">        <span class="keyword">if</span> g &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        h += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> p,q,g</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_key</span>(<span class="params">p,q,g</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">    x is private key, y is public key</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    x = getRandomRange(<span class="number">1</span>,q-<span class="number">1</span>)</span><br><span class="line">    y = <span class="built_in">pow</span>(g,x,p)</span><br><span class="line">    <span class="keyword">return</span> x,y</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sign</span>(<span class="params">m,p,q,g,x</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">    r,s is signature</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    k = getRandomRange(<span class="number">1</span>,q-<span class="number">1</span>)</span><br><span class="line">    r = <span class="built_in">pow</span>(g,k,p) % q</span><br><span class="line">    s = (<span class="built_in">pow</span>(k,-<span class="number">1</span>,q) * (<span class="built_in">int</span>(hashlib.sha256(m).hexdigest(),<span class="number">16</span>) + x*r)) % q</span><br><span class="line">    <span class="keyword">return</span> r,s</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">verify</span>(<span class="params">m,r,s,p,q,g,y</span>):</span><br><span class="line">    w = <span class="built_in">pow</span>(s,-<span class="number">1</span>,q)</span><br><span class="line">    u1 = (<span class="built_in">int</span>(hashlib.sha256(m).hexdigest(),<span class="number">16</span>) * w) % q</span><br><span class="line">    u2 = (r * w) % q</span><br><span class="line">    v = ((<span class="built_in">pow</span>(g,u1,p) * <span class="built_in">pow</span>(y,u2,p)) % p) % q</span><br><span class="line">    <span class="keyword">return</span> v == r</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p,q,g = generate_param(<span class="number">1024</span>,<span class="number">160</span>)</span><br><span class="line">    x,y = generate_key(p,q,g)</span><br><span class="line">    r,s = sign(<span class="string">b&#x27;Hello world&#x27;</span>,p,q,g,x)</span><br><span class="line">    <span class="built_in">print</span>(verify(<span class="string">b&#x27;Hello world&#x27;</span>,r,s,p,q,g,y))</span><br><span class="line">    <span class="built_in">print</span>(verify(<span class="string">b&#x27;Hello world!&#x27;</span>,r,s,p,q,g,y))</span><br></pre></td></tr></table></figure><h2 id="Attack"><a href="#Attack" class="headerlink" title="Attack"></a>Attack</h2><h3 id="Attack-on-DSA-with-signatures-made-with-k-k-1"><a href="#Attack-on-DSA-with-signatures-made-with-k-k-1" class="headerlink" title="Attack on DSA with signatures made with k, k+1"></a>Attack on DSA with signatures made with k, k+1</h3><blockquote><p>随便找了一个attack练练手，后面遇到了新的再补充</p></blockquote><p>根据</p><script type="math/tex; mode=display">s := k^{-1}(H(m)+xr) \mod q</script><p>我们可以得到</p><script type="math/tex; mode=display">\begin{align*}s_1k_1 &= H(m_1) + x*r_1 \mod q\\s_2k_1 + s_2 &= H(m_2) + x*r_2 \mod q\\\end{align*}</script><p>消去$k_1$</p><script type="math/tex; mode=display">\begin{align*}s_2s_1k_1 &= s_2H(m_1) + s_2*x*r_1 \mod q\\s_1s_2k_1 + s_1s_2 &= s_1H(m_2) + s_1*x*r_2 \mod q\end{align*}</script><p>我们可以得到</p><script type="math/tex; mode=display">s_1s_2 = s_1H(m_2)+(s_1*r_2-s_2*r_1)*x-s_2H(m_1) \mod q</script><p>从而</p><script type="math/tex; mode=display">x = \frac{s_1s_2 +s_2H(m_1)-s_1H(m_2)}{s_1r_2-s_2r_1} \mod q</script><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">attack_1</span>():</span><br><span class="line">    p,q,g = generate_param(<span class="number">1024</span>,<span class="number">160</span>)</span><br><span class="line">    x,y = generate_key(p,q,g)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sign_fault</span>(<span class="params">m1,m2,p,q,g,x</span>):</span><br><span class="line">        k = getRandomRange(<span class="number">1</span>,q-<span class="number">1</span>)</span><br><span class="line">        r1 = <span class="built_in">pow</span>(g,k,p) % q</span><br><span class="line">        s1 = (<span class="built_in">pow</span>(k,-<span class="number">1</span>,q) * (<span class="built_in">int</span>(hashlib.sha256(m1).hexdigest(),<span class="number">16</span>) + x*r1)) % q</span><br><span class="line">        r2 = <span class="built_in">pow</span>(g,k+<span class="number">1</span>,p) % q</span><br><span class="line">        s2 = (<span class="built_in">pow</span>(k+<span class="number">1</span>,-<span class="number">1</span>,q) * (<span class="built_in">int</span>(hashlib.sha256(m2).hexdigest(),<span class="number">16</span>) + x*r2)) % q</span><br><span class="line">        <span class="keyword">return</span> r1,s1,r2,s2</span><br><span class="line">    m1 = <span class="string">b&#x27;Hello world&#x27;</span></span><br><span class="line">    m2 = <span class="string">b&#x27;Hello world!&#x27;</span></span><br><span class="line">    r1,s1,r2,s2 = sign_fault(m1,m2,p,q,g,x)</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    x = \frac&#123;s_1s_2 +s_2H(m_1)-s_1H(m_2)&#125;&#123;s_1r_2-s_2r_1&#125; \mod q</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    x_ = ((s1*s2 + s2*<span class="built_in">int</span>(hashlib.sha256(m1).hexdigest(),<span class="number">16</span>) - s1*<span class="built_in">int</span>(hashlib.sha256(m2).hexdigest(),<span class="number">16</span>)) * <span class="built_in">pow</span>(s1*r2-s2*r1,-<span class="number">1</span>,q)) % q</span><br><span class="line">    <span class="built_in">print</span>(x == x_)</span><br></pre></td></tr></table></figure><h1 id="ECDSA"><a href="#ECDSA" class="headerlink" title="ECDSA"></a>ECDSA</h1><blockquote><p>其实 ECDSA和DSA差不多，无非就是从素域转移到椭圆曲线上，废话不多说，开干</p></blockquote><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>椭圆曲线数字签名算法（ECDSA）是使用椭圆曲线密码（ECC）对数字签名算法（DSA）的模拟。ECDSA于1999年成为ANSI标准，并于2000年成为IEEE和NIST标准。它在1998年既已为ISO所接受，并且包含它的其他一些标准亦在ISO的考虑之中。与普通的离散对数问题（discrete logarithm problem DLP）和大数分解问题（integer factorization problem IFP）不同，椭圆曲线离散对数问题（elliptic curve discrete logarithm problem ECDLP）没有亚指数时间的解决方法。因此椭圆曲线密码的单位比特强度要高于其他公钥体制。</p><h2 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h2><p>和DSA一样，ECDSA算法包含了四种操作：密钥生成、密钥分发、签名、验证</p><blockquote><p>写着写着，突然发现自己好像对于椭圆曲线没有做过系统的了解，先挖个坑，回头写一篇博客介绍一下。</p></blockquote><h3 id="密钥生成-1"><a href="#密钥生成-1" class="headerlink" title="密钥生成"></a>密钥生成</h3><p>只要Alice和Bob选定一个合适的曲线Curve和基点$G$，不过有一点要求，$G$的阶$n$必须是一个素数</p><blockquote><p>Indeed, we assume that every nonzero element of the ring<br>$\mathbb {Z} /n\mathbb {Z}$  is invertible, so that $\mathbb {Z} /n\mathbb {Z}$  must be a field. It implies that $n$ must be prime</p></blockquote><p>Alice 从 ${\displaystyle \{1\ldots n-1\}}$ 选择随机整数 $d_A$, 作为私钥；计算$Q_A = d_A \times G$作为公钥。</p><h3 id="密钥分发-1"><a href="#密钥分发-1" class="headerlink" title="密钥分发"></a>密钥分发</h3><p>签名者需要透过可信任的管道发布公钥<br>$Q_A$，并且安全地保护<br>$d_A$ 不被其他人知道。</p><h3 id="签名-1"><a href="#签名-1" class="headerlink" title="签名"></a>签名</h3><ol><li>计算 $e = \text{HASH}(m)$，$\text{HASH}$ 是一个密码哈希函数。</li><li>取 $z$ 为 e 最左边$|n|$比特，$|n|$ 为 $n$ 的比特长度。注意 $z$ 可以比 $n$ 大，但是不能比 $n$ 长。</li><li>从 ${\displaystyle \{1\ldots n-1\}}$ 选择随机整数 $k$</li><li>计算椭圆曲线上点 $(x_1,y_1)= k\times G$</li><li>计算 $r = x_1 \mod n$，如果 $r=0$，回到step 3</li><li>计算 $s = k^{-1}(z + rd_A )$，如果 $s=0$，回到step 3</li></ol><p>签名为 ${\displaystyle (r,s)}$ 组合，注意${\displaystyle (r,-s)}$也是有效的签名。</p><h3 id="验证签名-1"><a href="#验证签名-1" class="headerlink" title="验证签名"></a>验证签名</h3><ol><li>首先检验公钥$Q_A$的有效性：a. 是否为$O$点; b. 是否位于曲线上; c. $n\times Q_A$是否为$O$点。</li><li>验证$r,s\in [1,n-1]$</li><li>计算 $e = \text{HASH}(m)$，$\text{HASH}$ 是一个密码哈希函数。</li><li>取 $z$ 为 e 最左边$|n|$比特，$|n|$ 为 $n$ 的比特长度。 </li><li>计算$u_1 = zs^{-1}\mod n, \,u_2=rs^{-1}\mod n$</li><li>计算椭圆曲线上点 $(x_1,y_1)=u_1\times G+u_2\times Q_A \mod n$，如果 $(x_1,y_1)=O$,签名无效。</li><li>如果$r\equiv x_1 \mod n$，签名有效。</li></ol><h2 id="Correctness-1"><a href="#Correctness-1" class="headerlink" title="Correctness"></a>Correctness</h2><script type="math/tex; mode=display">\begin{align*}C &= u_1\times G+u_2\times Q_A \mod n \\&= u_1\times G+u_2d_A\times G \mod n\\&= (u_1+u_2d_A)\times G \mod n\\&= (zs^{-1}+rs^{-1}d_A)\times G \mod n\\&= ((z+rd_A)s^{-1})\times G \mod n\\&= ((z+rd_A)(k^{-1}(z + rd_A ))^{-1})\times G \mod n\\&= ((z+rd_A)(k^{-1}(z + rd_A ))^{-1})\times G \mod n\\&= k \times G \mod n\\&= Q_A\end{align*}</script><h2 id="公钥恢复"><a href="#公钥恢复" class="headerlink" title="公钥恢复"></a>公钥恢复</h2><ol><li>计算$R=(x_1,y_1)$，$x_1$ 是 $r,r+n,r+2n\dots$中的其中一个。</li><li>计算$u_1 = -zr^{-1}\mod n, \,u_2=sr^{-1}\mod n$</li><li>计算$Q_A = (x_A,y_A) = u_1G+u_2R $.</li></ol><p>$Q_A$即为公钥</p><h3 id="Correctness-2"><a href="#Correctness-2" class="headerlink" title="Correctness"></a>Correctness</h3><script type="math/tex; mode=display">\begin{align*}Q^\prime_A &= u_1G+u_2R \mod n\\&=sr^{-1} R - zr^{-1}G\mod n\\&=sr^{-1} kG - zr^{-1}G\mod n\\&=(k^{-1}(z+d_Ar)r^{-1} k - zr^{-1})G\mod n\\&=d_A G\mod n\\&= Q_A\end{align*}</script><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">point</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,x,y,z = <span class="number">1</span>,curve = <span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> x != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">assert</span> (x**<span class="number">3</span> + curve.a * x * z**<span class="number">4</span> + curve.b * z**<span class="number">6</span> - y**<span class="number">2</span> ) % curve.p == <span class="number">0</span></span><br><span class="line">        <span class="variable language_">self</span>.x = x</span><br><span class="line">        <span class="variable language_">self</span>.y = y</span><br><span class="line">        <span class="variable language_">self</span>.z = z</span><br><span class="line">        <span class="variable language_">self</span>.curve = curve</span><br><span class="line">        <span class="variable language_">self</span>.invert_2 = inverse(<span class="number">2</span>,<span class="variable language_">self</span>.curve.p)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">to_affine</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.z == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> point(<span class="literal">None</span>,<span class="literal">None</span>,<span class="number">0</span>,<span class="variable language_">self</span>.curve)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> point(<span class="variable language_">self</span>.x * inverse(<span class="variable language_">self</span>.z**<span class="number">2</span>,<span class="variable language_">self</span>.curve.p) % <span class="variable language_">self</span>.curve.p,<span class="variable language_">self</span>.y * inverse(<span class="variable language_">self</span>.z**<span class="number">3</span>,<span class="variable language_">self</span>.curve.p) % <span class="variable language_">self</span>.curve.p,<span class="number">1</span>,<span class="variable language_">self</span>.curve)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self,other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.curve != other.curve:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;Curve not match&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.z == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> other</span><br><span class="line">        <span class="keyword">elif</span> other.z == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l1 = (<span class="variable language_">self</span>.x * other.z * other.z) % <span class="variable language_">self</span>.curve.p</span><br><span class="line">            l2 = (other.x * <span class="variable language_">self</span>.z * <span class="variable language_">self</span>.z) % <span class="variable language_">self</span>.curve.p</span><br><span class="line">            l3 = (l1 -l2) % <span class="variable language_">self</span>.curve.p</span><br><span class="line">            l4 = (<span class="variable language_">self</span>.y * other.z**<span class="number">3</span>) % <span class="variable language_">self</span>.curve.p</span><br><span class="line">            l5 = (other.y * <span class="variable language_">self</span>.z**<span class="number">3</span>) % <span class="variable language_">self</span>.curve.p</span><br><span class="line">            l6 = (l4 - l5) % <span class="variable language_">self</span>.curve.p</span><br><span class="line">            <span class="keyword">if</span> l3 == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> l6 == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="variable language_">self</span>.double()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> point(<span class="literal">None</span>,<span class="literal">None</span>,<span class="number">0</span>,<span class="variable language_">self</span>.curve)</span><br><span class="line">            l7 = (l1 + l2) % <span class="variable language_">self</span>.curve.p</span><br><span class="line">            l8 = (l4 + l5) % <span class="variable language_">self</span>.curve.p</span><br><span class="line">            x3 = (l6**<span class="number">2</span> - l7*l3**<span class="number">2</span>) % <span class="variable language_">self</span>.curve.p</span><br><span class="line">            l9 = (l7 * l3**<span class="number">2</span> - <span class="number">2</span> * x3) % <span class="variable language_">self</span>.curve.p</span><br><span class="line">            y3 = ((l9 * l6 -l8 * l3**<span class="number">3</span>) * <span class="variable language_">self</span>.invert_2) % <span class="variable language_">self</span>.curve.p</span><br><span class="line">            z3 = <span class="variable language_">self</span>.z * other.z * l3 % <span class="variable language_">self</span>.curve.p</span><br><span class="line">            <span class="keyword">return</span> point(x3,y3,z3,<span class="variable language_">self</span>.curve)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__mul__</span>(<span class="params">self,k</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.x == <span class="literal">None</span> <span class="keyword">and</span> <span class="variable language_">self</span>.y == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> point(<span class="literal">None</span>,<span class="literal">None</span>,<span class="number">0</span>,<span class="variable language_">self</span>.curve)</span><br><span class="line">        q = point(<span class="literal">None</span>,<span class="literal">None</span>,<span class="number">0</span>,<span class="variable language_">self</span>.curve)</span><br><span class="line">        r = <span class="variable language_">self</span></span><br><span class="line">        <span class="keyword">while</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> k &amp; <span class="number">1</span>:</span><br><span class="line">                q = q + r</span><br><span class="line">            r = r.double()</span><br><span class="line">            k &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> q</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__rmul__</span>(<span class="params">self,k</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.__mul__(k)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self,other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.x == other.x <span class="keyword">and</span> <span class="variable language_">self</span>.y == other.y <span class="keyword">and</span> <span class="variable language_">self</span>.curve == other.curve</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__ne__</span>(<span class="params">self,other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> <span class="variable language_">self</span>.__eq__(other)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Point : (%d,%d) &#x27;</span> % (<span class="variable language_">self</span>.x,<span class="variable language_">self</span>.y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">double</span>(<span class="params">self</span>):</span><br><span class="line">        l1 = (<span class="number">3</span> * <span class="variable language_">self</span>.x * <span class="variable language_">self</span>.x + <span class="variable language_">self</span>.curve.a * <span class="variable language_">self</span>.z**<span class="number">4</span>) % <span class="variable language_">self</span>.curve.p</span><br><span class="line">        l2 = (<span class="number">4</span> * <span class="variable language_">self</span>.x * <span class="variable language_">self</span>.y * <span class="variable language_">self</span>.y) % <span class="variable language_">self</span>.curve.p</span><br><span class="line">        l3 = (<span class="number">8</span> * <span class="variable language_">self</span>.y**<span class="number">4</span>) % <span class="variable language_">self</span>.curve.p</span><br><span class="line">        x3 = (l1**<span class="number">2</span> - <span class="number">2</span> * l2) % <span class="variable language_">self</span>.curve.p</span><br><span class="line">        y3 = (l1 * (l2 - x3) - l3) % <span class="variable language_">self</span>.curve.p</span><br><span class="line">        z3 = (<span class="number">2</span> * <span class="variable language_">self</span>.y * <span class="variable language_">self</span>.z) % <span class="variable language_">self</span>.curve.p</span><br><span class="line">        <span class="keyword">return</span> point(x3,y3,z3,<span class="variable language_">self</span>.curve)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">curve</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,a,b,p</span>):</span><br><span class="line">        <span class="variable language_">self</span>.a = a</span><br><span class="line">        <span class="variable language_">self</span>.b = b</span><br><span class="line">        <span class="variable language_">self</span>.p = p</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_on_curve</span>(<span class="params">self,x,y </span>) -&gt; <span class="built_in">bool</span> :</span><br><span class="line">        <span class="keyword">return</span> (y**<span class="number">2</span> - x**<span class="number">3</span> - <span class="variable language_">self</span>.a*x - <span class="variable language_">self</span>.b) % <span class="variable language_">self</span>.p == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">y</span>(<span class="params">self,x</span>):</span><br><span class="line">        a = (x**<span class="number">3</span> + <span class="variable language_">self</span>.a*x + <span class="variable language_">self</span>.b) % <span class="variable language_">self</span>.p</span><br><span class="line">        y = mod_root(a,<span class="variable language_">self</span>.p)</span><br><span class="line">        <span class="keyword">if</span> y <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> y</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Curve : y^2 = x^3 + %dx + %d (mod %d)&#x27;</span> % (<span class="variable language_">self</span>.a,<span class="variable language_">self</span>.b,<span class="variable language_">self</span>.p)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self,other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.a == other.a <span class="keyword">and</span> <span class="variable language_">self</span>.b == other.b <span class="keyword">and</span> <span class="variable language_">self</span>.p == other.p</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__ne__</span>(<span class="params">self,other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> <span class="variable language_">self</span>.__eq__(other)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lucas_seq</span>(<span class="params">X,Y,k</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; lucas sequence</span></span><br><span class="line"><span class="string">    :returns: lucas sequence</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    U0 = <span class="number">0</span></span><br><span class="line">    U1 = <span class="number">1</span></span><br><span class="line">    V0 = <span class="number">2</span></span><br><span class="line">    V1 = X</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>):</span><br><span class="line">        U2 = X*U1 + Y*U0</span><br><span class="line">        V2 = X*V1 + Y*V0</span><br><span class="line">        U0 = U1</span><br><span class="line">        U1 = U2</span><br><span class="line">        V0 = V1</span><br><span class="line">        V1 = V2</span><br><span class="line">    <span class="keyword">return</span> U2,V2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mod_root</span>(<span class="params">g,p</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; modular square root</span></span><br><span class="line"><span class="string">    :x: number</span></span><br><span class="line"><span class="string">    :p: prime</span></span><br><span class="line"><span class="string">    :returns: modular square root</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> p % <span class="number">4</span> == <span class="number">3</span>:</span><br><span class="line">        y = <span class="built_in">pow</span>(g,(p+<span class="number">1</span>)//<span class="number">4</span>,p)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">pow</span>(y,<span class="number">2</span>,p) == g:</span><br><span class="line">            <span class="keyword">return</span> y</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">elif</span> p % <span class="number">8</span> == <span class="number">5</span>:</span><br><span class="line">        u = p // <span class="number">8</span></span><br><span class="line">        z = <span class="built_in">pow</span>(g,<span class="number">2</span>*u+<span class="number">1</span>,p)</span><br><span class="line">        <span class="keyword">if</span> z == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pow</span>(g,u+<span class="number">1</span>,p)</span><br><span class="line">        <span class="keyword">elif</span> z == p-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>*g*<span class="built_in">pow</span>(<span class="number">4</span>*g,u,p) % p</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        u = p // <span class="number">8</span></span><br><span class="line">        Y = g</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            X = random.randint(<span class="number">1</span>, p-<span class="number">1</span>)</span><br><span class="line">            U,V = lucas_seq(X, Y, <span class="number">4</span>*u+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">pow</span>(V,<span class="number">2</span>,p) == <span class="number">4</span>*Y % p:</span><br><span class="line">                <span class="keyword">return</span> (V//<span class="number">2</span>) % p</span><br><span class="line">            <span class="keyword">elif</span> (U % p == <span class="number">1</span>) <span class="keyword">or</span> (U % p == p-<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">test_p = &#123;<span class="string">&#x27;curve_p&#x27;</span>:curve(<span class="number">0x787968B4FA32C3FD2417842E73BBFEFF2F3C848B6831D7E0EC65228B3937E498</span>,<span class="number">0x63E4C6D3B23B0C849CF84241484BFE48F61D59A5B16BA06E6E12D1DA27C5249A</span>,<span class="number">0x8542D69E4C044F18E8B92435BF6FF7DE457283915C45517D722EDB8B08F1DFC3</span>),</span><br><span class="line"><span class="string">&#x27;G&#x27;</span>:point(<span class="number">0x421DEBD61B62EAB6746434EBC3CC315E32220B3BADD50BDC4C4E6C147FEDD43D</span>,<span class="number">0x0680512BCBB42C07D47349D2153B70C4E5D7FDFCBFA36EA1A85841B9E46E09A2</span>,<span class="number">1</span>,curve(<span class="number">0x787968B4FA32C3FD2417842E73BBFEFF2F3C848B6831D7E0EC65228B3937E498</span>,<span class="number">0x63E4C6D3B23B0C849CF84241484BFE48F61D59A5B16BA06E6E12D1DA27C5249A</span>,<span class="number">0x8542D69E4C044F18E8B92435BF6FF7DE457283915C45517D722EDB8B08F1DFC3</span>)),</span><br><span class="line"><span class="string">&#x27;n&#x27;</span>:<span class="number">0x8542D69E4C044F18E8B92435BF6FF7DD297720630485628D5AE74EE7C32E79B7</span>,</span><br><span class="line"><span class="string">&#x27;h&#x27;</span>:<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ecdsa</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,table = test_p</span>):</span><br><span class="line">        <span class="variable language_">self</span>.curve = table[<span class="string">&#x27;curve_p&#x27;</span>]</span><br><span class="line">        <span class="variable language_">self</span>.G = table[<span class="string">&#x27;G&#x27;</span>]</span><br><span class="line">        <span class="variable language_">self</span>.n = table[<span class="string">&#x27;n&#x27;</span>]</span><br><span class="line">        <span class="variable language_">self</span>.h = table[<span class="string">&#x27;h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ecdsa_KeyGen</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27; SM2 key generation</span></span><br><span class="line"><span class="string">        :returns: public key, private key</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            dA = random.randint(<span class="number">1</span>,<span class="variable language_">self</span>.n - <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># dA = 0x1649AB77A00637BD5E2EFE283FBF353534AA7F7CB89463F208DDBC2920BB0DA0</span></span><br><span class="line">            PA = dA * <span class="variable language_">self</span>.G</span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.ecdsa_keycheck(PA) == <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> PA,dA</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ecdsa_keycheck</span>(<span class="params">self,PA</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27; ecdsa key check</span></span><br><span class="line"><span class="string">        :PA: public key</span></span><br><span class="line"><span class="string">        :returns: True or False</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> PA.x == <span class="literal">None</span> <span class="keyword">and</span> PA.y == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> PA.x &lt; <span class="number">0</span> <span class="keyword">or</span> PA.x &gt; <span class="variable language_">self</span>.curve.p <span class="keyword">or</span> PA.y &lt; <span class="number">0</span> <span class="keyword">or</span> PA.y &gt; <span class="variable language_">self</span>.curve.p:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.curve != PA.curve:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">self</span>.n * PA.to_affine()).x != <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="variable language_">self</span>.n * PA)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ecdsa_sign</span>(<span class="params">self,m,dA</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27; ecdsa sign</span></span><br><span class="line"><span class="string">        :PA: public key</span></span><br><span class="line"><span class="string">        :dA: private key</span></span><br><span class="line"><span class="string">        :m: message</span></span><br><span class="line"><span class="string">        :returns: signature</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        e = <span class="built_in">int</span>(hashlib.sha256(m).hexdigest(),<span class="number">16</span>)</span><br><span class="line">        <span class="keyword">if</span> e.bit_length() &gt; <span class="variable language_">self</span>.n.bit_length():</span><br><span class="line">            z = e &gt;&gt; (e.bit_length() - <span class="variable language_">self</span>.n.bit_length())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            z = e</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            k = random.randint(<span class="number">1</span>,<span class="variable language_">self</span>.n - <span class="number">1</span>)</span><br><span class="line">            C = (k * <span class="variable language_">self</span>.G).to_affine()</span><br><span class="line">            r = (C.x % <span class="variable language_">self</span>.n)</span><br><span class="line">            <span class="keyword">if</span> r == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            s = (inverse(k,<span class="variable language_">self</span>.n) * (z + r * dA)) % <span class="variable language_">self</span>.n</span><br><span class="line">            <span class="keyword">if</span> s != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> r,s</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ecdsa_verify</span>(<span class="params">self,m,r,s,PA</span>):</span><br><span class="line">        e = <span class="built_in">int</span>(hashlib.sha256(m).hexdigest(),<span class="number">16</span>)</span><br><span class="line">        <span class="keyword">if</span> e.bit_length() &gt; <span class="variable language_">self</span>.n.bit_length():</span><br><span class="line">            z = e &gt;&gt; (e.bit_length() - <span class="variable language_">self</span>.n.bit_length())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            z = e</span><br><span class="line">        u1 = z * inverse(s,<span class="variable language_">self</span>.n) % <span class="variable language_">self</span>.n</span><br><span class="line">        u2 = r * inverse(s,<span class="variable language_">self</span>.n) % <span class="variable language_">self</span>.n</span><br><span class="line">        C = (u1 * <span class="variable language_">self</span>.G + u2 * PA).to_affine()</span><br><span class="line">        <span class="keyword">return</span> (C.x % <span class="variable language_">self</span>.n) == r</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    exp = ecdsa()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;---------------------------------&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;prameters: of Curve&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+]ECC: &#x27;</span>,exp.curve)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+]G: &#x27;</span>,exp.G)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+]n: &#x27;</span>,exp.n)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+]h: &#x27;</span>,exp.h)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;---------------------------------&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Key Generation:&#x27;</span>)</span><br><span class="line">    PA,dA = exp.ecdsa_KeyGen()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+]Public Key: &#x27;</span>,PA)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+]Private Key: &#x27;</span>,dA)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;---------------------------------&#x27;</span>)</span><br><span class="line">    m = <span class="string">b&#x27;Hello world&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Message: &#x27;</span>,m)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;---------------------------------&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Signature:&#x27;</span>)</span><br><span class="line">    r,s = exp.ecdsa_sign(m,dA)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+]r: &#x27;</span>,r)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+]s: &#x27;</span>,s)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;---------------------------------&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Verification:&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+]Result: &#x27;</span>,exp.ecdsa_verify(m,r,s,PA))</span><br></pre></td></tr></table></figure><h2 id="Attack-1"><a href="#Attack-1" class="headerlink" title="Attack"></a>Attack</h2><h3 id="Attack-on-ECDSA-with-signatures-made-with-same-k"><a href="#Attack-on-ECDSA-with-signatures-made-with-same-k" class="headerlink" title="Attack on ECDSA with signatures made with same k"></a>Attack on ECDSA with signatures made with same k</h3><p>根据</p><script type="math/tex; mode=display">s = k^{-1}(z+d_Ar)</script><p>我们可以得到</p><script type="math/tex; mode=display">\begin{align*}s_1 &= k^{-1}(z_1+d_Ar)\mod n\\s_2 &= k^{-1}(z_2+d_Ar) \mod n\end{align*}</script><p>从而有</p><script type="math/tex; mode=display">s_1-s_2 = k^{-1}(z_1-z_2) \mod n\\k = \frac{z_1-z_2}{s_1-s_2} \mod n</script><p>从而可以得到</p><script type="math/tex; mode=display">d_A = \dfrac{s_1k-z_1}{r}</script><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">attack_1</span>():</span><br><span class="line">    exp = ecdsa()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;---------------------------------&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;prameters: of Curve&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+]ECC: &#x27;</span>,exp.curve)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+]G: &#x27;</span>,exp.G)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+]n: &#x27;</span>,exp.n)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+]h: &#x27;</span>,exp.h)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;---------------------------------&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Key Generation:&#x27;</span>)</span><br><span class="line">    PA,dA = exp.ecdsa_KeyGen()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+]Public Key: &#x27;</span>,PA)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+]Private Key: &#x27;</span>,dA)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;---------------------------------&#x27;</span>)</span><br><span class="line">    m1 = <span class="string">b&#x27;Hello world&#x27;</span></span><br><span class="line">    m2 = <span class="string">b&#x27;Hello world!&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Message: &#x27;</span>,m1)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Message: &#x27;</span>,m2)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;---------------------------------&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Signature:&#x27;</span>)</span><br><span class="line">    e = <span class="built_in">int</span>(hashlib.sha256(m1).hexdigest(),<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">if</span> e.bit_length() &gt; exp.n.bit_length():</span><br><span class="line">        z1 = e &gt;&gt; (e.bit_length() - exp.n.bit_length())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        z1 = e</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        k = random.randint(<span class="number">1</span>,exp.n - <span class="number">1</span>)</span><br><span class="line">        C = (k * exp.G).to_affine()</span><br><span class="line">        r1 = (C.x % exp.n)</span><br><span class="line">        <span class="keyword">if</span> r1 == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        s1 = (inverse(k,exp.n) * (z1 + r1 * dA)) % exp.n</span><br><span class="line">        <span class="keyword">if</span> s1 != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    e = <span class="built_in">int</span>(hashlib.sha256(m2).hexdigest(),<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">if</span> e.bit_length() &gt; exp.n.bit_length():</span><br><span class="line">        z2 = e &gt;&gt; (e.bit_length() - exp.n.bit_length())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        z2 = e</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        C = (k * exp.G).to_affine()</span><br><span class="line">        r2 = (C.x % exp.n)</span><br><span class="line">        <span class="keyword">if</span> r2 == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        s2 = (inverse(k,exp.n) * (z2 + r2 * dA)) % exp.n</span><br><span class="line">        <span class="keyword">if</span> s2 != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+]r1: &#x27;</span>,r1)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+]s1: &#x27;</span>,s1)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+]r2: &#x27;</span>,r2)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+]s2: &#x27;</span>,s2)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;---------------------------------&#x27;</span>)</span><br><span class="line">    k = (z1 - z2) * inverse(s1 - s2,exp.n) % exp.n</span><br><span class="line">    dA_ = ((s1 * k - z1) * inverse(r1,exp.n)) % exp.n</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Private Key: &#x27;</span>,dA_)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;---------------------------------&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(dA==dA_)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="EdDSA"><a href="#EdDSA" class="headerlink" title="EdDSA"></a>EdDSA</h1><!--http://aandds.com/blog/eddsa.html --><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><div id="refer-anchor-1"></div><ul><li>[1] <a href="https://zh.wikipedia.org/wiki/数字签名算法">维基百科-数字签名算法</a></li><li>[2] <a href="https://crypto.stackexchange.com/questions/7904/attack-on-dsa-with-signatures-made-with-k-k1-k2">Attack on DSA with signatures made with k, k+1, k+2</a></li><li>[3] <a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm#cite_note-2">Elliptic Curve Digital Signature Algorithm</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Cryptography </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KEA-Knowledge-of-Exponent Assumption</title>
      <link href="/2023/12/12/%E7%AE%80%E5%8D%95%E8%AE%B2%E8%AE%B2KEA/"/>
      <url>/2023/12/12/%E7%AE%80%E5%8D%95%E8%AE%B2%E8%AE%B2KEA/</url>
      
        <content type="html"><![CDATA[<h2 id="Assumption"><a href="#Assumption" class="headerlink" title="Assumption"></a>Assumption</h2><p><strong>指数知识假设</strong> (knowledge of exponent assumption, KEA)  是指给定 $p$ 阶群 $\mathbb{G}$ 和群 $\mathbb{G}_T$ 、双线性映射关系 $e: \mathbb{G} \times \mathbb{G} \rightarrow \mathbb{G}_T 、 \mathbb{G}$ 上生成元 $g$ 及 $g^\alpha$, 在不知道 $a$ 的情况下难以构造 $\hat{c} 、 c$ 且 $\hat{c}=c^\alpha$, 其中 $c=g^a, \hat{c}=\left(g^\alpha\right)^a$. </p><p><strong>$q$ 阶指数知识假设</strong> ( $q$-Power PKE, 即 $q$-PKE 假设)是指给定 $\left(g, g^x, \cdots, g^{x^q}, g^\alpha, g^{\alpha x}, \cdots, g^{\alpha x^q}\right)$, 在不知道 $a_0, a_1, \cdots, a_q$的情况下难以构造 $\hat{c} 、 c$ 且 $\hat{c}=c^\alpha$,其中 $c=\prod_{i=0}^q\left(g^{x^i}\right)^{a_i}, \hat{c}=\prod_{i=0}^q\left(g^{\alpha x^i}\right)^{a_i}$. 值得注意的是, $q$ - PKE 假设是一种不可证伪 (non-falsifiable)的假设.</p><h2 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h2><ol><li><p>Alice 有一个值$a$，她想要 Bob 对其进行任意指数的求幂（这里 $a$ 是一个有限域群的生成元），唯一的要求是只能对  $a$ 进行求幂，为了保证这一点，她要:</p><ul><li>选择一个随机数$\alpha$</li><li>计算$a^\prime = a^\alpha (\mod n)$</li><li>提供一个元组$(a,a^\prime)$给Bob，然后让他对这两个值执行求幂运算，返回结果元组$(b,b^\prime)$，这里的指数”$\alpha -$变换”依然保持不变，即$b^\alpha=b^\prime (\mod n)$</li></ul></li><li><p>因为 Bob 无法从元组 $(a, a’)$ 中提取 $α$ 的值，通过暴力破解也难以实现，那就可以推断 Bob 生成有效元组的唯一方法就是执行下面的步骤：</p><ul><li>选择一个值 $c$</li><li>计算 $b=a^c(mod n)$ 和 $b’ = (a^\prime)^ c (mod n)$</li><li>回复 $(b,b’)$</li></ul></li><li><p>有了回复的元组和 <em>α</em>，Alice 就可以验证等式：</p><script type="math/tex; mode=display">b^\alpha = b'</script><script type="math/tex; mode=display">(a^c)^\alpha = (a^\prime)^c</script><script type="math/tex; mode=display">a^{c\cdot \alpha} = (a^\alpha)^c</script><p>结论是：</p><ul><li>Bob 在元组的两个值的计算上都用了同一个指数（即 $c$）</li><li>Bob 只能用 Alice 原本的元组来保持 $α$ 关系</li><li>Bob 知道指数 $c$，因为构造验证值 $(b,b^′)$ 的唯一方式是用同一个指数</li><li>Alice 并不知道 $c$，这和 Bob 不知道 $α$ 的原因一样</li><li>虽然 $c$ 是被加密的，但它的可能取值范围并不足够大到保持其零知识的性质</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Zero Knowledge Proof </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zero Knowledge Proof </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
